<!DOCTYPE html>
<html lang="ua">
<head>
    <meta charset="UTF-8">
    <title>MySQL</title>
    <link href="../../style.css" rel="stylesheet"/>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/googlecode.min.css"
          rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
<div class="wrapper">
    <a href="../index.html">back</a>

    <h1>MySQL</h1>
    <h2>Зміст</h2>
    <div class="content-table">
        <ol>
            <li><a href="#1">Вступ до SQL і MySQL</a></li>
            <ol>
                <li><a href="#1.1">Які є основні типи баз даних і що таке MySQL</a></li>
                <li><a href="#1.2">Як встановити та налаштувати MySQL</a></li>
            </ol>
            <li><a href="#2">Основні команди SQL</a></li>
            <ol>
                <li><a href="#2.1">Створення бази даних та таблиці</a></li>
                <li><a href="#2.2">Вставлення, оновлення та видалення даних</a></li>
                <li><a href="#2.3">Вибірка даних: SELECT команда</a></li>
                <li><a href="#2.4">Пошук даних: WHERE команда</a></li>
                <li><a href="#2.5">Сортування даних: ORDER BY команда</a></li>
                <li><a href="#2.6">Групування та агрегатні функції: GROUP BY та HAVING команди</a></li>
            </ol>
            <li><a href="#3">Розширені команди SQL</a></li>
            <ol>
                <li><a href="#3.1">З'єднання таблиць: JOIN команда</a></li>
                <li><a href="#3.2">Підзапити: SUBQUERY команда</a></li>
                <li><a href="#3.3">Транзакції та блокування: BEGIN, COMMIT та ROLLBACK команди</a></li>
                <li><a href="#3.4">Індекси та оптимізація запитів</a></li>
                <li><a href="#3.5">Агрегатні функції</a></li>
                <li><a href="#3.6">Скалярні функції</a></li>
            </ol>
            <li><a href="#4">Робота з MySQL</a></li>
            <ol>
                <li><a href="#4.1">Робота з MySQL з використанням інтерфейсу командного рядка</a></li>
                <li><a href="#4.2">Збереження та відновлення баз даних</a></li>
                <li><a href="#4.3">Відношення - OTO, OTM, MTM</a></li>
            </ol>
            <li><a href="#5">Розширені функції</a></li>
            <ol>
                <li><a href="#5.1">Процедури</a></li>
                <ol>
                    <li><a href="#5.1.1">Створення та виклик процедур</a></li>
                    <ol>
                        <li><a href="#5.1.1.1">Опис синтаксису для створення процедур (CREATE PROCEDURE)</a></li>
                        <li><a href="#5.1.1.2">Використання IN, OUT та INOUT параметрів</a></li>
                        <li><a href="#5.1.1.3">Виклик процедур за допомогою команди CALL</a></li>
                        <li><a href="#5.1.1.4">Приклад коду для створення та виклику процедури</a></li>
                    </ol>
                    <li><a href="#5.1.2">Контроль потоку в процедурах</a></li>
                    <ol>
                        <li><a href="#5.1.2.1">Використання IF, CASE, LOOP, WHILE та REPEAT конструкцій</a></li>
                        <li><a href="#5.1.2.2">Синтаксис та приклади коду для кожної конструкції</a></li>
                    </ol>
                    <li><a href="#5.1.3">Обробка помилок та ексепшнів в процедурах</a></li>
                    <ol>
                        <li><a href="#5.1.3.1">Оголошення та використання обробників помилок (DECLARE HANDLER)</a></li>
                        <li><a href="#5.1.3.2">Типи обробників: CONTINUE, EXIT та UNDO</a></li>
                        <li><a href="#5.1.3.3">Використання SIGNAL та RESIGNAL для генерації та пропагації помилок</a>
                        </li>
                        <li><a href="#5.1.3.4">Приклади коду для обробки помилок та ексепшнів</a></li>
                    </ol>
                </ol>
                <li><a href="#5.2">View</a></li>
                <li><a href="#5.3">Тригери</a></li>
                <li><a href="#5.4">Привілеї. GRANT, REVOKE</a></li>
                <li><a href="#5.5">Нормалізація</a></li>
            </ol>
        </ol>
    </div>
    <div class="content">
        <div id="1">
            <h2>1. Що таке JDBC</h2>
            <div id="1.1">
                <h3>1.1 Які є основні типи баз даних і що таке MySQL</h3>
                <p>Існує кілька основних типів баз даних, які використовуються для зберігання та обробки даних:</p>
                <ul>
                    <li>
                        Реляційна база даних (Relational Database) - це набір таблиць зі структурованими даними,
                        які містять стовпці з назвами та типами даних. Зв'язки між таблицями встановлюються за
                        допомогою ключів. Сюди відносяться MySQL, PostgreSQL, MSSQL, та ін.
                    </li>
                    <li>
                        Ієрархічна база даних (Hierarchical Database) - це база даних, де дані зберігаються у вигляді
                        дерева з батьківськими та дочірніми вузлами. Кожен вузол може мати багато дочірніх вузлів, але
                        тільки один батьківський вузол.
                    </li>
                    <li>
                        Мережева база даних (Network Database) - це база даних, де дані зберігаються у вигляді мережі
                        з вузлами та зв'язками. Кожен вузол може мати багато дочірніх та батьківських вузлів.
                    </li>
                    <li>
                        Об'єктно-орієнтована база даних (Object-Oriented Database) - це база даних, де дані зберігаються
                        у вигляді об'єктів з методами та властивостями. Об'єкти можуть бути унаслідувані один від
                        одного, що дозволяє створювати ієрархії об'єктів.
                    </li>
                </ul>
            </div>
            <div id="1.2">
                <h3>1.2 Як встановити та налаштувати MySQL</h3>
                <div>
                    <p>Для встановлення MySQL необхідно:</p>
                    <ul>
                        <li>Завантажити останню версію MySQL з <a href="https://dev.mysql.com/downloads/mysql/">офіційного
                            сайту</a>.
                        </li>
                        <li>Запустити інсталятор та дотримуватись <a
                                href="https://dev.mysql.com/doc/mysql-installation-excerpt/5.7/en/">інструкцій
                            встановлення</a>.
                        </li>
                        <li>Після завершення встановлення запустіть службу MySQL. (<a
                                href="https://www.tutorialspoint.com/starting-and-stopping-mysql-server">info</a>)
                        </li>
                    </ul>
                </div>
                <div>
                    <h4>Налаштування MySQL</h4>
                    <p>
                        Для правильної роботи MySQL необхідно налаштувати деякі параметри. Основні налаштування
                        знаходяться
                        в файлі конфігурації MySQL - my.cnf. Основні параметри, які можна налаштувати:
                    </p>
                    <ul>
                        <li><b>port</b> - порт, на якому MySQL слухає запити.</li>
                        <li><b>bind-address</b> - IP-адреса, на якій MySQL слухає запити.</li>
                        <li><b>max_connections</b> - максимальна кількість одночасних з'єднань до бази даних.</li>
                        <li><b>query_cache_size</b> - розмір кешу запитів.</li>
                        <li><b>innodb_buffer_pool_size</b> - розмір буферного пулу InnoDB.</li>
                        <li><b>log_error</b> - шлях до файлу, в який будуть записуватися повідомлення про помилки.</li>
                    </ul>
                    <p>Після внесення змін до файлу конфігурації необхідно перезапустити службу MySQL, щоб зміни
                        вступили в
                        дію.</p>
                </div>
                <div>
                    <h4>Перші кроки з MySQL</h4>
                    <p>Після встановлення та налаштування MySQL необхідно створити базу даних та користувачів, які
                        матимуть до неї доступ. Для цього можна використовувати консольний інтерфейс MySQL - командний
                        рядок.</p>
                    <p>Для входу до MySQL з консолі потрібно ввести команду:</p>
                    <pre><code class="language-shell">
    mysql -u username -p password
                    </code></pre>
                    <p>Після входу до MySQL можна створити базу даних командою:</p>
                    <pre><code class="language-sql">
    CREATE DATABASE database_name;
                    </code></pre>
                    <p>
                        Після створення бази даних та користувача можна почати використовувати SQL-запити для створення
                        таблиць та заповнення їх даними.
                    </p>
                </div>
                <div>
                    <h4>Інструменти для роботи з MySQL</h4>
                    <p>Для роботи з MySQL можна використовувати різні інструменти:</p>
                    <ul>
                        <li><b>MySQL Workbench</b> - графічний інтерфейс для роботи з MySQL, який містить зручний
                            редактор
                            запитів, можливість перегляду та редагування таблиць та інші корисні інструменти.
                        </li>
                        <li><b>phpMyAdmin</b> - веб-інтерфейс для роботи з MySQL, який дозволяє легко керувати базами
                            даних через браузер.
                        </li>
                        <li>
                            <b>MySQL CLI</b> - консольний інтерфейс для роботи з MySQL, який дозволяє виконувати запити
                            та
                            керувати базами даних з командного рядка.
                        </li>
                    </ul>
                </div>
                <div>
                    <h4>Завершення роботи з MySQL</h4>
                    <p>Після закінчення роботи з MySQL важливо правильно закрити з'єднання до бази даних. Для цього
                        використовуйте команду:</p>
                    <pre><code class="language-sql">
            EXIT;
                    </code></pre>
                    <p>або просто закрийте консольний інтерфейс чи графічний інтерфейс.</p>
                </div>
            </div>
        </div>
        <div id="2">
            <h2>2. Основні команди SQL</h2>
            <div id="2.1">
                <h3>2.1 Створення бази даних та таблиці</h3>
                <p>Для створення бази даних та таблиці, необхідно виконати декілька кроків:</p>
                <ol>
                    <li>
                        <div>
                            <p>
                                Створіть нову базу даних: Для створення нової бази даних в MySQL необхідно
                                використовувати
                                команду CREATE DATABASE з назвою бази даних. Наприклад:
                            </p>
                            <pre><code class="language-sql">
    CREATE DATABASE mydatabase;
                            </code></pre>
                        </div>
                    </li>
                    <li>
                        <div>
                            <p>
                                Створіть нову таблицю: Після створення бази даних, можна створити таблицю. Для цього
                                використовуйте команду CREATE TABLE. Наприклад:
                            </p>
                            <pre><code class="language-sql">
    CREATE TABLE users (
        id INT PRIMARY KEY,
        name VARCHAR(50),
        age INT
    );
                            </code></pre>
                            <p>
                                У цьому прикладі ми створюємо таблицю "users" з трьома колонками: "id", "name" та "age".
                                Колонка "id" є первинним ключем таблиці.
                            </p>
                        </div>
                    </li>
                    <li>
                        <p>
                            Встановіть типи даних: При створенні таблиці потрібно вказати тип даних для кожної колонки.
                            Тип даних визначає, який тип даних може бути збережений у кожній колонці. Наприклад, INT
                            використовується для зберігання цілих чисел, VARCHAR для зберігання рядків з вказаною
                            довжиною.
                        </p>
                    </li>
                    <li>
                        <p>
                            Встановіть обмеження та індекси: Обмеження та індекси допомагають забезпечити правильність
                            даних в таблиці та швидкий доступ до даних. Наприклад, PRIMARY KEY встановлює первинний ключ
                            таблиці, який унікальний для кожного запису, а FOREIGN KEY встановлює зв'язок з іншою
                            таблицею.
                        </p>
                    </li>
                </ol>
                <p></p>
                <p></p>
            </div>
            <div id="2.2">
                <h3>2.2 Вставлення, оновлення та видалення даних</h3>
                <div>
                    <h4>Вставлення даних</h4>
                    <p>
                        Для вставлення даних в таблицю використовується команда INSERT. Синтаксис команди виглядає
                        наступним чином:
                    </p>
                    <pre><code class="language-sql">
    INSERT INTO table_name (column1, column2, column3, ...)
    VALUES (value1, value2, value3, ...);
                    </code></pre>
                    <p>
                        де table_name - назва таблиці, column1, column2, column3 - назви колонок таблиці, а value1,
                        value2, value3 - значення, які потрібно вставити. Якщо значення для колонок не вказані, вони
                        заповнюються значеннями за замовчуванням.
                    </p>
                    <p>Приклад вставки даних в таблицю students:</p>
                    <pre><code class="language-sql">
    INSERT INTO students (name, age, grade)
    VALUES ('John', 18, 'A');
                    </code></pre>
                </div>
                <div>
                    <h4>Оновлення даних</h4>
                    <p>
                        Для оновлення даних в таблиці використовується команда UPDATE. Синтаксис команди виглядає
                        наступним чином:
                    </p>
                    <pre><code class="language-sql">
    UPDATE table_name
    SET column1 = value1, column2 = value2, ...
    WHERE condition;
                    </code></pre>
                    <p>
                        де table_name - назва таблиці, column1, column2 - назви колонок таблиці, value1, value2 - нові
                        значення для відповідних колонок, а condition - умова, яка визначає, які записи потрібно
                        оновити.
                    </p>
                    <p>Приклад оновлення даних в таблиці students:</p>
                    <pre><code class="language-sql">
    UPDATE students
    SET grade = 'B'
    WHERE name = 'John';
                    </code></pre>
                </div>
                <div>
                    <h4>Видалення даних</h4>
                    <p>
                        Для видалення даних з таблиці використовується команда DELETE. Синтаксис команди виглядає
                        наступним чином:
                    </p>
                    <pre><code class="language-sql">
    DELETE FROM table_name
    WHERE condition;
                    </code></pre>
                    <p>
                        де table_name - назва таблиці, а condition - умова, яка визначає, які записи потрібно
                        видалити.
                    </p>
                    <p>Приклад видалення запису з таблиці students:</p>
                    <pre><code class="language-sql">
    DELETE FROM students
    WHERE name = 'John';
                    </code></pre>
                    <p>Також можна видалити всі рядки з таблиці, використовуючи команду без WHERE:</p>
                    <pre><code class="language-sql">
    DELETE FROM students;
                    </code></pre>
                    <p>Уважно використовуйте команду DELETE, оскільки вона безповоротно видаляє дані з таблиці.</p>
                </div>
            </div>
            <div id="2.3">
                <h3>2.3 Вибірка даних: команда SELECT</h3>
                <p>
                    Команда SELECT використовується для отримання даних з таблиці. Вона може бути досить складною, але
                    за допомогою кількох простих правил можна легко зрозуміти її синтаксис.
                </p>
                <div>
                    <h4>Синтаксис команди SELECT</h4>
                    <p>Основний синтаксис команди SELECT має такий вигляд:</p>
                    <pre><code class="language-sql">
    SELECT [список стовпців] FROM [назва таблиці] WHERE [умова відбору]
                    </code></pre>
                    <ul>
                        <li>
                            <b>`список стовпців`</b> - перелік стовпців, які необхідно вибрати. Якщо потрібно вибрати
                            всі
                            стовпці, можна вказати зірочку `*`.
                        </li>
                        <li><b>`назва таблиці`</b> - назва таблиці, з якої необхідно вибрати дані.</li>
                        <li>
                            <b>умова відбору</b> - умова, за якою відбираються записи з таблиці. Ця частина команди є
                            необов'язковою.
                        </li>
                    </ul>
                    <p>
                        Наприклад, якщо потрібно вибрати всі дані з таблиці students, запит буде мати наступний вигляд:
                    </p>
                    <pre><code class="language-sql">
    SELECT * FROM students;
                    </code></pre>
                </div>
                <div>
                    <h4>Відбір даних за умовою</h4>
                    <p>
                        Умова відбору в команді SELECT використовується для вибірки даних, які відповідають певній
                        умові. Умова відбору може бути досить складною і включати кілька умов.
                    </p>
                    <p>
                        Наприклад, якщо потрібно вибрати всіх студентів, які навчаються на факультеті "Інформатика" і
                        мають середній бал більше 4, то запит буде мати наступний вигляд:
                    </p>
                    <pre><code class="language-sql">
    SELECT * FROM students WHERE faculty = 'Інформатика' AND average_score > 4;
                    </code></pre>
                    <p>
                        В цьому запиті WHERE вказує на те, що вибірка повинна бути здійснена за умовою, а AND вказує на
                        те, що умови повинні бути виконані обидві.
                    </p>
                </div>
            </div>
            <div id="2.4">
                <h3>2.4 Пошук даних: WHERE команда</h3>
                <p>
                    Команда WHERE є однією з найбільш використовуваних команд у MySQL, оскільки вона дозволяє
                    фільтрувати дані в результатах запиту на основі певних критеріїв.
                </p>
                <p>Синтаксис команди WHERE виглядає наступним чином:</p>
                <pre><code class="language-sql">
    SELECT column1, column2, ...
    FROM table_name
    WHERE condition;
                </code></pre>
                <p>
                    У рядку WHERE ви можете вказати умови, які повинні бути виконані для відбору певних рядків з
                    таблиці. Умови можуть містити логічні оператори, такі як AND, OR та NOT, а також порівняльні
                    оператори, такі як =, <>, <, >, <= та >=.
                </p>
                <p>
                    Наприклад, якщо ви хочете вибрати всі рядки з таблиці users, де значення стовпця age менше 30, ви
                    можете скористатися таким запитом:
                </p>
                <pre><code class="language-sql">
    SELECT *
    FROM users
    WHERE age < 30;
                </code></pre>
                <p>
                    Якщо ви хочете вибрати всі рядки з таблиці orders, де значення стовпців customer_id і order_date
                    задовольняють певні умови, ви можете скористатися таким запитом:
                </p>
                <pre><code class="language-sql">
    SELECT *
    FROM orders
    WHERE customer_id = 1234 AND order_date >= '2022-01-01';
                </code></pre>
                <p>
                    Крім того, команда WHERE може бути використана для фільтрації даних на основі шаблону за допомогою
                    оператора LIKE. Цей оператор дозволяє виконувати пошук рядків, які містять певні символи або фрази.
                    Наприклад, запит нижче виведе всі рядки з таблиці users, де значення стовпця name містить слово
                    "John":
                </p>
                <pre><code class="language-sql">
    SELECT *
    FROM users
    WHERE name LIKE '%John%';
                </code></pre>
                <p>
                    У цьому запиті оператор % є символом підстановки, який означає будь-який рядок символів. Таким
                    чином, умова LIKE '%John%' буде відповідати будь-якому рядку, який містить слово "John".
                </p>
                <p></p>
            </div>
            <div id="2.5">
                <h3>2.5 Сортування даних: ORDER BY команда</h3>
                <p>
                    Команда ORDER BY дозволяє сортувати дані в результатах запиту за певними критеріями. Зазвичай ця
                    команда використовується разом з командою SELECT, щоб вивести дані в певному порядку.
                </p>
                <p>
                    Синтаксис команди ORDER BY виглядає наступним чином:
                </p>
                <div class="code-block">
                    <pre>
                        <code class="language-sql">
    SELECT column1, column2, ...
    FROM table_name
    ORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ...;
                        </code>
                    </pre>
                </div>
                <p>
                    У рядку ORDER BY ви можете вказати назви стовпців, які потрібно відсортувати, та напрямок сортування
                    (ASC або DESC). За замовчуванням дані сортуються в порядку зростання (ASC), але ви можете змінити
                    напрямок сортування на спадний (DESC).
                </p>
                <p>
                    Наприклад, якщо ви хочете відсортувати таблицю users за стовпцем age в порядку зростання, ви можете
                    скористатися таким запитом:
                </p>
                <div class="code-block">
                    <pre>
                        <code class="language-sql">
    SELECT *
    FROM users
    ORDER BY age ASC;
                        </code>
                    </pre>
                </div>
                <p>
                    Якщо ви хочете відсортувати таблицю orders за стовпцями customer_id та order_date, в порядку
                    спадання, ви можете скористатися таким запитом:
                </p>
                <div class="code-block">
                    <pre>
                        <code class="language-sql">
    SELECT *
    FROM orders
    ORDER BY customer_id DESC, order_date DESC;
                        </code>
                    </pre>
                </div>
                <p>
                    Команда ORDER BY також може бути використана для сортування даних за результатами обчислень.
                    Наприклад, якщо ви хочете відобразити рядки таблиці products у порядку спадання цін за десять
                    останніх днів, ви можете скористатися таким запитом:
                </p>
                <div class="code-block">
                    <pre>
                        <code class="language-sql">
    SELECT product_name, AVG(price) as avg_price
    FROM products
    WHERE date >= DATE_SUB(NOW(), INTERVAL 10 DAY)
    GROUP BY product_name
    ORDER BY avg_price DESC;
                        </code>
                    </pre>
                </div>
                <p>
                    У цьому запиті ми використовуємо команди AVG, DATE_SUB та NOW для обчислення середньої ціни за
                    останні 10 днів для кожного продукту. Після цього ми групуємо рядки за назвою продукту і
                    відображаємо результати в порядку спадання середньої ціни.
                </p>
                <p>
                    Команда ORDER BY може бути використана разом з командою LIMIT, щоб відобразити обмежену кількість
                    рядків, відсортованих за певним критерієм. Наприклад, якщо ви хочете відобразити топ-10 продуктів за
                    середньою ціною, ви можете скористатися таким запитом:
                </p>
                <div class="code-block">
                    <pre>
                        <code class="language-sql">
    SELECT product_name, AVG(price) as avg_price
    FROM products
    GROUP BY product_name
    ORDER BY avg_price DESC
    LIMIT 10;
                        </code>
                    </pre>
                </div>
                <p>
                    У цьому запиті ми використовуємо команду LIMIT 10, щоб відобразити тільки перші 10 рядків,
                    відсортованих за спаданням середньої ціни.
                </p>
                <p>
                    Важливо пам'ятати, що порядок, в якому ви вказуєте стовпці для сортування, може вплинути на
                    результати. Наприклад, якщо ви використовуєте команду ORDER BY з двома стовпцями, порядок, в якому
                    ви їх вказуєте, може вплинути на порядок сортування. Також необхідно звернути увагу на тип даних у
                    стовпці, за яким ви виконуєте сортування, оскільки це може вплинути на порядок сортування та
                    результати запиту.
                </p>
                <p>
                    У випадку, якщо ви хочете відобразити дані випадковим чином, ви можете використовувати команду ORDER
                    BY разом з функцією RAND():
                </p>
                <div class="code-block">
                    <pre>
                        <code class="language-sql">
    SELECT *
    FROM table_name
    ORDER BY RAND();
                        </code>
                    </pre>
                </div>
                <p>
                    Цей запит поверне дані випадковим чином, оскільки ми використовуємо функцію RAND(), щоб визначити
                    порядок сортування.
                </p>
                <p>
                    У цьому розділі ми розглянули команду ORDER BY, яка дозволяє відсортувати дані в результатах запиту
                    за певними критеріями. Ми також розглянули різні варіанти використання цієї команди та наголосили на
                    важливості правильного вибору критеріїв сортування та їх порядку.
                </p>
            </div>
            <div id="2.6">
                <h3>2.6 Групування та агрегатні функції: GROUP BY та HAVING команди</h3>
                <p>
                    Однією з найважливіших можливостей реляційних баз даних є здатність до групування даних та
                    використання агрегатних функцій для обробки цих груп. В MySQL це досягається за допомогою команд
                    GROUP BY та HAVING.
                </p>
                <p>
                    GROUP BY команда використовується для групування рядків в таблиці за певними стовпцями. Наприклад,
                    якщо ви маєте таблицю з продуктами та їх цінами, ви можете групувати рядки за назвою продукту, щоб
                    отримати загальну ціну для кожного продукту. Синтаксис GROUP BY виглядає наступним чином:
                </p>
                <div class="code-block">
                    <pre>
                        <code class="language-sql">
    SELECT column1, column2, ...
    FROM table_name
    GROUP BY column1, column2, ...;
                        </code>
                    </pre>
                </div>
                <p>Де column1, column2, ... - це стовпці, за якими ви хочете групувати дані.</p>
                <p>
                    HAVING команда використовується для фільтрації результатів групування на основі умов, які не можна
                    включити до WHERE команди. Наприклад, якщо ви хочете вибрати тільки ті групи, де загальна ціна
                    продукту перевищує 1000, ви можете використовувати HAVING команду. Синтаксис HAVING виглядає
                    наступним чином:
                </p>
                <div class="code-block">
                    <pre>
                        <code class="language-sql">
    SELECT column1, column2, ...
    FROM table_name
    GROUP BY column1, column2, ...
    HAVING condition;
                        </code>
                    </pre>
                </div>
                <p>
                    Де condition - це умова, яка визначає, які групи будуть включені у результати запиту.
                </p>
                <p>
                    Також, для обчислення агрегатних функцій в групованому запиті можна використовувати такі функції, як
                    SUM, AVG, MIN, MAX та COUNT.
                </p>
                <p>
                    Наприклад, щоб отримати середню ціну кожного продукту в таблиці, ви можете використовувати такий
                    запит:
                </p>
                <div class="code-block">
                    <pre>
                        <code class="language-sql">
    SELECT product_name, AVG(price)
    FROM products
    GROUP BY product_name;
                        </code>
                    </pre>
                </div>
                <p>Цей запит групує рядки за назвою продукту та обчислює середню ціну для кожної групи:</p>
                <div class="code-block">
                    <pre>
                        <code class="language-sql">
    SELECT product_name, AVG(price) AS average_price
    FROM products
    GROUP BY product_name;
                        </code>
                    </pre>
                </div>
                <p>
                    У цьому прикладі, GROUP BY оператор групує рядки за значенням стовпця product_name. За допомогою
                    функції AVG, ми обчислюємо середню ціну для кожної групи продуктів.
                </p>
                <p>
                    Можна використовувати також інші агрегатні функції, наприклад SUM, MIN, MAX, COUNT і т. д.
                </p>
                <p>
                    Наступний приклад демонструє використання HAVING команди для вибірки груп з середньою ціною, яка
                    більше за 100:
                </p>
                <div class="code-block">
                    <pre>
                        <code class="language-sql">
    SELECT product_name, AVG(price) AS average_price
    FROM products
    GROUP BY product_name
    HAVING AVG(price) > 100;
                        </code>
                    </pre>
                </div>
                <p>
                    У цьому запиті, HAVING оператор дозволяє фільтрувати результати за умовою, що середня ціна продукту
                    більша за 100.
                </p>
                <p>
                    При використанні GROUP BY та HAVING, важливо пам'ятати, що оператори SELECT, що не є агрегатними, не
                    можуть бути включені в SELECT список, якщо вони не є частиною GROUP BY списку.
                </p>
            </div>
        </div>
        <div id="3">
            <h2>3. Розширені команди SQL</h2>
            <div id="3.1">
                <h3>3.1 З'єднання таблиць: JOIN команда</h3>
                <p>
                    В більшості випадків дані, що містяться в базі даних, розділені між різними таблицями. Для отримання
                    потрібної інформації необхідно об'єднати ці таблиці в запиті до бази даних. Для цього
                    використовуються з'єднання таблиць або JOIN команда.
                </p>
                <p>
                    JOIN команда використовується для об'єднання двох або більше таблиць в один запит. Команда JOIN
                    створює результат об'єднання двох таблиць зі спільними даними в залежності від умови з'єднання.
                </p>
                <p>Синтаксис команди JOIN виглядає наступним чином:</p>
                <div class="code-block">
                    <pre>
                        <code class="language-sql">
    SELECT * FROM table1 JOIN table2 ON table1.column = table2.column;
                        </code>
                    </pre>
                </div>
                <p>
                    У цій команді table1 та table2 є назвами таблиць, які ми хочемо об'єднати, а column є спільним
                    стовпцем у цих таблицях. Умова з'єднання повинна бути задана у розділі ON. Умова з'єднання може бути
                    довільною логічною операцією, наприклад AND або OR.
                </p>
                <p>Існує кілька типів JOIN команд:</p>
                <ol>
                    <li>
                        INNER JOIN: цей тип JOIN команди повертає лише ті записи, які мають спільні значення у обох
                        таблицях.
                    </li>
                    <li>
                        LEFT JOIN: цей тип JOIN команди повертає всі записи з таблиці зліва (першої таблиці в команді
                        JOIN), а також спільні записи з правої таблиці. Якщо записи в правій таблиці не мають спільних
                        значень з записами в лівій таблиці, то вони замінюються значеннями NULL.
                    </li>
                    <li>
                        RIGHT JOIN: цей тип JOIN команди повертає всі записи з таблиці справа (другої таблиці в команді
                        JOIN), а також спільні записи з лівої таблиці. Якщо записи в лівій таблиці не мають спільних
                        значень з записами в правій таблиці, то вони замінюються значеннями NULL.
                    </li>
                    <li>
                        FULL OUTER JOIN: цей тип JOIN команди повертає всі записи з обох таблиць, включаючи спільні
                        записи, а також записи, які не мають спільних значень. Якщо значення не знайдено в одній з
                        таблиць, то воно замінюється значенням NULL.
                    </li>
                </ol>
                <p>
                    Для вибору типу JOIN команди необхідно визначити, які записи потрібно вибрати з таблиць. Наприклад,
                    якщо ми хочемо вибрати всі записи з однієї таблиці, а тільки спільні записи з другої таблиці, то
                    можна використати LEFT JOIN команду. Якщо ж потрібно вибрати всі записи з обох таблиць, то необхідно
                    використати FULL OUTER JOIN команду.
                </p>
                <p>
                    Наступним кроком після використання JOIN команди може бути групування результатів або застосування
                    фільтру до результатів. Для цього можна використовувати додаткові команди, такі як GROUP BY, HAVING,
                    ORDER BY та інші.
                </p>
                <p>
                    Наприклад, можна використати JOIN команду для отримання списку клієнтів, які здійснювали замовлення,
                    разом з інформацією про замовлення та товари. Запит може мати наступний вигляд:
                </p>
                <pre><code class="language-sql">
    SELECT customers.customer_name, orders.order_date, products.product_name
    FROM customers
    JOIN orders ON customers.customer_id = orders.customer_id
    JOIN order_items ON orders.order_id = order_items.order_id
    JOIN products ON order_items.product_id = products.product_id;
                </code></pre>
                <p>
                    Цей запит поверне ім'я клієнта, дату замовлення та назву товару для кожного замовлення.
                </p>
                <p>
                    Умова з'єднання вказує, що необхідно з'єднати таблиці по customer_id у таблицях customers та orders,
                    по order_id у таблицях orders та order_items, та по product_id у таблицях order_items та products.
                </p>
                <p>
                    З JOIN командою можна також виконувати інші операції, такі як підрахунок кількості записів,
                    середнього значення або максимального значення. Для цього можна використовувати агрегатні функції,
                    такі як COUNT, AVG або MAX.
                </p>
                <p>
                    Узагальнюючи, JOIN команда є потужним інструментом для об'єднання даних з різних джерел в один
                    результат. За допомогою JOIN команди можна об'єднати дані з двох таблиць або більше, виконати
                    операції з'єднання, фільтрації, сортування та агрегації.
                </p>
                <p>
                    Однак необхідно пам'ятати, що використання JOIN команди може призвести до складних запитів, які
                    можуть бути важкими для оптимізації. Також необхідно враховувати, що велика кількість записів в
                    таблицях може призвести до повільної роботи запитів.
                </p>
                <p>
                    Тому для покращення продуктивності бази даних необхідно дотримуватися кращих практик проектування
                    баз даних та використовувати індекси для поліпшення швидкодії запитів.
                </p>
                <p>
                    У даних часах бази даних є важливою складовою сучасних додатків, тому вміння розуміти та ефективно
                    використовувати мову SQL є дуже важливим для розробки програмного забезпечення. Наведені вище
                    концепції та приклади використання JOIN команди є лише основою для подальшого вивчення та розширення
                    знань в галузі баз даних.
                </p>
            </div>
            <div id="3.2">
                <h3>3.2 Підзапити: SUBQUERY команда</h3>
                <p>SUBQUERY команда дозволяє використовувати результат запиту в якості умови в іншому запиті.</p>
                <p>
                    Основною ідеєю підзапитів є те, що ми можемо виконувати запити, що повертають набір результатів, і
                    використовувати ці результати для обмеження набору даних, на яких ми виконуємо наступний запит.
                </p>
                <p>
                    Основні типи підзапитів:
                </p>
                <ol>
                    <li>
                        Підзапити в SELECT
                        <ul>
                            <li>
                                Повернення даних, що відповідають умовам, що базуються на значеннях одного поля, які
                                порівнюються з іншими значеннями того ж поля в тому ж же запиті.
                            </li>
                            <li>
                                Приклад: SELECT name, age FROM users WHERE age > (SELECT AVG(age) FROM users);
                            </li>
                        </ul>
                    </li>
                    <li>
                        Підзапити в FROM
                        <ul>
                            <li>Використання підзапиту як таблиці в основному запиті.</li>
                            <li>
                                Приклад: SELECT AVG(age) as avg_age FROM (SELECT age FROM users WHERE city = 'New York')
                                as newyork_users;
                            </li>
                        </ul>
                    </li>
                    <li>
                        Підзапити в WHERE
                        <ul>
                            <li>Використання підзапиту в якості умови для фільтрації даних.</li>
                            <li>
                                Приклад: SELECT name, age FROM users WHERE city = (SELECT city FROM employees WHERE name
                                = 'John Doe');
                            </li>
                        </ul>
                    </li>
                    <li>
                        Підзапити в INSERT, UPDATE та DELETE
                        <ul>
                            <li>Використання підзапиту для зміни, видалення чи вставки даних в таблицю.</li>
                            <li>
                                Приклад: UPDATE users SET age = (SELECT AVG(age) FROM employees WHERE department =
                                'Marketing') WHERE department = 'Marketing';
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Підзапити можуть бути вкладеними, тобто один підзапит може містити інший підзапит.</p>
                <p>
                    Важливо пам'ятати, що використання підзапитів може призвести до складних запитів та впливати на
                    продуктивність. Тому варто обирати оптимальний спосіб використання підзапитів та уникати їх зайвого
                    використання.
                </p>
            </div>
            <div id="3.3">
                <h3>3.3 Транзакції та блокування: BEGIN, COMMIT та ROLLBACK команди</h3>
                <p>
                    Транзакції є ключовим аспектом управління даними в базах даних. Вони забезпечують цілісність даних
                    та дозволяють виконувати групу запитів як одну атомарну операцію.
                </p>
                <p>
                    Основні команди, пов'язані з транзакціями, включають:
                </p>
                <ol>
                    <li>BEGIN - початок транзакції.</li>
                    <li>COMMIT - збереження результатів транзакції.</li>
                    <li>ROLLBACK - відміна транзакції та відновлення даних до попереднього стану.</li>
                </ol>
                <p>
                    При виконанні групи запитів, які потрібно виконати як одну операцію, слід розпочати транзакцію за
                    допомогою команди BEGIN. Всі запити, які виконуються після цього, вважаються частинами транзакції.
                </p>
                <p>
                    Після виконання групи запитів, які складають транзакцію, потрібно використати команду COMMIT для
                    збереження результатів. Якщо виконання транзакції було успішним, то COMMIT збереже зміни в базі
                    даних. Якщо виконання транзакції не було успішним, то команда ROLLBACK скасує всі зміни, які було
                    внесено до бази даних.
                </p>
                <p>
                    Одним з ключових аспектів управління даними в базах даних є блокування. Блокування дозволяє
                    запобігти доступу до даних, які можуть бути змінені в процесі транзакції, тим самим гарантуючи їх
                    цілісність та унеможливлюючи конфлікти між транзакціями.
                </p>
                <p>
                    Основні види блокування включають:
                </p>
                <ol>
                    <li>
                        SHARE (S) - дозволяє одній транзакції читати дані, поки інші транзакції зберігають доступ до
                        них.
                    </li>
                    <li>
                        EXCLUSIVE (X) - забороняє будь-яку іншу транзакцію зчитувати або змінювати дані, які були
                        заблоковані. Це блокування використовується в тих випадках, коли потрібно внести зміни в дані та
                        необхідно запобігти доступу до них іншим транзакціям.
                    </li>
                </ol>
                <p>
                    MySQL також надає можливість різних рівнів блокування, які можуть бути використані залежно від
                    потреб. Рівні блокування включають:
                </p>
                <ol>
                    <li>
                        READ UNCOMMITTED - це рівень блокування, де транзакція може читати дані, які були заблоковані
                        іншою транзакцією. Це найменший рівень блокування та може призвести до помилок при одночасному
                        доступі до даних.
                    </li>
                    <li>
                        READ COMMITTED - це рівень блокування, де транзакція може читати тільки ті дані, які були
                        підтверджені (збережені в базі даних) іншою транзакцією. Це забезпечує більш високий рівень
                        ізоляції даних.
                    </li>
                    <li>
                        REPEATABLE READ - це рівень блокування, де транзакція заблокує дані, які вона читає, до того, як
                        вони будуть змінені або підтверджені іншою транзакцією. Це забезпечує ще більший рівень ізоляції
                        даних.
                    </li>
                    <li>
                        SERIALIZABLE - це найвищий рівень блокування, де транзакції заблокують всі дані, які вони
                        читають або змінюють, до того, як вони будуть збережені в базі даних. Це забезпечує найвищий
                        рівень ізоляції даних, але може призвести до проблем з продуктивністю.
                    </li>
                </ol>
                <p>
                    Крім використання операцій блокування внутрішньої обробки, користувач також може використовувати
                    команди LOCK TABLES та UNLOCK TABLES, щоб заблокувати та розблокувати таблиці в MySQL.
                </p>
                <p>
                    Команда LOCK TABLES дозволяє заблокувати одну або кілька таблиць для читання або запису. Синтаксис
                    команди наступний:
                </p>
                <pre><code class="language-sql">
    LOCK TABLES table_name [AS alias] lock_type [, table_name [AS alias] lock_type] ...
                </code></pre>
                <p>
                    Де table_name - це ім'я таблиці, яку потрібно заблокувати, alias - псевдонім для таблиці (опційно),
                    а lock_type - це тип блокування, який може бути READ для блокування таблиці для читання або WRITE
                    для блокування таблиці для запису.
                </p>
                <p>
                    Наприклад, команда LOCK TABLES users WRITE заблокує таблицю "users" для запису.
                </p>
                <p>
                    Після виконання команди LOCK TABLES, користувач може виконувати будь-які операції заблокованими
                    таблицями без обмежень. Однак, будь-яка спроба доступу до іншої таблиці буде заблокована, доки
                    таблиці не будуть розблоковані.
                </p>
                <p>
                    Для розблокування таблиць користувач повинен виконати команду UNLOCK TABLES;
                </p>
                <p>
                    Після виконання цієї команди всі таблиці, які були заблоковані, будуть розблоковані.
                </p>
                <p>
                    Важливо пам'ятати, що команди LOCK TABLES та UNLOCK TABLES можуть впливати на продуктивність
                    системи, особливо якщо виконується багато запитів з блокуванням. Тому варто розглянути можливість
                    використання транзакцій замість команд блокування, якщо це можливо.
                </p>
            </div>
            <div id="3.4">
                <h3>3.4 Індекси та оптимізація запитів</h3>
                <p>
                    Одним з найбільш важливих аспектів проектування баз даних є оптимізація запитів. Хоча можна написати
                    запити для виконання будь-якої операції, ефективність запитів може значно відрізнятися залежно від
                    того, як добре вони оптимізовані.
                </p>
                <p>
                    Індекси - це структури даних, які дозволяють швидко знаходити рядки в таблиці, що відповідають
                    певному умові. Індекси можуть бути створені на одному або декількох стовпцях таблиці. Кожен індекс
                    має своє ім'я, яке може бути використане для посилання на нього в SQL-запитах.
                </p>
                <p>
                    У MySQL можна створювати різні типи індексів, такі як PRIMARY KEY, UNIQUE, і INDEX.
                </p>
                <ul>
                    <li>
                        PRIMARY KEY: Індекс, який унікально ідентифікує кожен рядок в таблиці. PRIMARY KEY зазвичай
                        створюється на одному або декількох полях, що є унікальними, таких як ідентифікатор користувача.
                    </li>
                    <li>
                        UNIQUE: Індекс, який забезпечує унікальність значень у певному полі або групі полів. Наприклад,
                        UNIQUE індекс може бути створений на полі email, щоб забезпечити, що кожен користувач має
                        унікальний email.
                    </li>
                    <li>
                        INDEX: Індекс, який дозволяє швидкий доступ до даних за певними полями. INDEX може бути
                        створений на одному або декількох полях, які використовуються часто в операціях SELECT, ORDER
                        BY, або GROUP BY.
                    </li>
                </ul>
                <p>
                    Створення індексів дозволяє зменшити час виконання запитів до бази даних. Проте, створення занадто
                    багатьох індексів може призвести до збільшення розміру таблиць і повільного виконання операцій з
                    модифікації таблиць, таких як INSERT, UPDATE і DELETE.
                </p>
                <p>
                    Крім того, індекси повинні бути оптимізовані для конкретних операцій, які часто виконуються в вашому
                    додатку. Наприклад, якщо ваш додаток часто виконує запити для пошуку рядків за декількома полями, ви
                    можете створити складений індекс на цих полях.
                </p>
                <p>
                    Нарешті, індекси потрібно підтримувати в хорошому стані, тобто періодично виконувати процеси
                    оптимізації та реорганізації. Це може бути важливим для забезпечення швидкодії операцій з базою
                    даних з часом. У MySQL є кілька інструментів, які можна використовувати для підтримки індексів в
                    хорошому стані.
                </p>
                <p>
                    Одним з них є команда OPTIMIZE TABLE, яка виконує оптимізацію таблиці та її індексів. Ця команда
                    перетворює фізичне розташування даних таблиці, щоб забезпечити більш ефективний доступ до даних.
                    Вона також виконує реорганізацію індексів, що може допомогти уникнути проблем, пов'язаних з
                    нерівномірним розподілом даних в індексах.
                </p>
                <p>
                    Іншим інструментом для підтримки індексів є EXPLAIN. Цей оператор дозволяє аналізувати плани
                    виконання запитів та оцінювати ефективність індексів для конкретних запитів. Ви можете
                    використовувати результати цієї команди, щоб визначити, чи потрібні додаткові індекси, або чи можна
                    оптимізувати існуючі.
                </p>
                <p>
                    Крім того, ви можете використовувати MySQL Performance Schema для моніторингу роботи індексів та
                    профілювання запитів. Performance Schema дозволяє вам визначити, які запити найбільш ефективні та
                    які індекси найбільше використовуються в вашому додатку.
                </p>
                <p>
                    Створення індексу на одному стовпці
                </p>
                <pre><code class="language-sql">
    CREATE INDEX idx_customer_name ON customers (customer_name);
                </code></pre>
                <p>
                    Це створить індекс на стовпці customer_name таблиці customers. Це призведе до швидшого пошуку за
                    іменами клієнтів в таблиці.
                </p>
                <p>
                    Видалення індексу:
                </p>
                <pre><code class="language-sql">
    DROP INDEX idx_users_name ON users;
                </code></pre>
                <p>
                    Створення індексу на декількох стовпцях
                </p>
                <pre><code class="language-sql">
    CREATE INDEX idx_customer_name_city ON customers (customer_name, city);
                </code></pre>
                <p>
                    Це створить складений індекс на стовпцях customer_name та city таблиці customers. Цей індекс
                    дозволить швидше виконувати запити, які фільтрують за ім'ям клієнта та містом.
                </p>
                <p>
                    Використання індексу для підтримки з'єднання таблиць
                </p>
                <pre><code class="language-sql">
    SELECT *
    FROM customers
    JOIN orders
    ON customers.customer_id = orders.customer_id
    WHERE orders.order_date BETWEEN '2022-01-01' AND '2022-12-31';
                </code></pre>
                <p>
                    У цьому прикладі, якщо немає індексу на customer_id у таблиці orders, то запит буде виконуватись
                    повільно. Але якщо створити індекс на customer_id, то запит буде виконуватись значно швидше.
                </p>
                <p>
                    Використання оптимізації запитів з індексами
                </p>
                <pre><code class="language-sql">
    EXPLAIN SELECT *
    FROM customers
    WHERE customer_name LIKE 'John%';
                </code></pre>
                <p>
                    У цьому прикладі EXPLAIN дозволяє проаналізувати план виконання запиту. Якщо у таблиці customers є
                    індекс на стовпці customer_name, то запит буде виконуватись значно швидше, оскільки MySQL буде
                    використовувати цей індекс для пошуку записів з іменем, яке починається на "John"
                </p>
                <p>
                    Оптимізація таблиці та її індексів:
                </p>
                <pre><code class="language-sql">
    OPTIMIZE TABLE users;
                </code></pre>
                <p>
                    Цей запит виконує оптимізацію таблиці та її індексів, щоб забезпечити більш ефективний доступ до
                    даних.
                </p>
                <p>
                    Ці приклади показують різноманітні операції з індексами в MySQL. Налаштування та підтримка індексів
                    може зменшити час відповіді на запити та збільшити продуктивність вашого додатку.
                </p>
            </div>
            <div id="3.5">
                <h3>3.5 Агрегатні функції</h3>
                <p>
                    Агрегатні функції - це функції, які дозволяють обчислювати різні статистичні показники для групи
                    рядків в таблиці. Найчастіше вони використовуються для обчислення суми, середнього значення,
                    мінімального та максимального значення для групи записів. В MySQL доступні такі агрегатні функції:
                </p>
                <ul>
                    <li>SUM(): обчислює суму значень у стовпчику для групи рядків.</li>
                    <li>AVG(): обчислює середнє значення у стовпчику для групи рядків.</li>
                    <li>MIN(): знаходить найменше значення у стовпчику для групи рядків.</li>
                    <li>MAX(): знаходить найбільше значення у стовпчику для групи рядків.</li>
                    <li>COUNT(): обчислює кількість рядків у групі.</li>
                </ul>
                <p>
                    Для використання агрегатних функцій потрібно використовувати команду GROUP BY, яка групує рядки
                    таблиці за значенням певного стовпчика. Ось приклад використання команди GROUP BY разом з
                    агрегатними функціями:
                </p>
                <pre><code class="language-sql">
    SELECT category, SUM(price) FROM products GROUP BY category;
                </code></pre>
                <p>
                    Цей запит вибирає категорію товарів та суму їхніх цін для кожної категорії. GROUP BY групує рядки
                    таблиці за значенням стовпчика category.
                </p>
                <p>
                    Також, агрегатні функції можуть бути використані в команді HAVING, щоб фільтрувати групи рядків за
                    значенням обчислених агрегатних функцій. Ось приклад використання команди HAVING:
                </p>
                <pre><code class="language-sql">
    SELECT category, AVG(price) FROM products GROUP BY category HAVING AVG(price) > 100;
                </code></pre>
                <p>
                    Цей запит вибирає категорію товарів та їхнє середнє значення цін для кожної категорії, а потім
                    фільтрує результати за допомогою HAVING, щоб вибрати тільки ті категорії, в середнє значення цін для
                    яких більше 100.
                </p>
                <p>
                    Додатково, можна використовувати агрегатні функції разом з функціями, які працюють з рядками, такими
                    як CONCAT() або SUBSTR(), щоб отримати результати, які містять як статистичні показники, так і рядки
                    даних.
                </p>
                <p>
                    Наприклад, ось запит, який повертає список користувачів з їхнім повним ім'ям та кількістю замовлень,
                    які вони зробили:
                </p>
                <pre><code class="language-sql">
    SELECT CONCAT(first_name, ' ', last_name) AS full_name, COUNT(*) AS order_count FROM customers
    JOIN orders ON customers.customer_id = orders.customer_id
    GROUP BY customers.customer_id;
                </code></pre>
                <p>
                    У цьому запиті ми використовуємо функцію CONCAT(), щоб об'єднати ім'я та прізвище користувача в одне
                    поле full_name, а потім обчислюємо кількість замовлень, які зробив кожний користувач, за допомогою
                    COUNT(*). GROUP BY групує результати за ідентифікатором користувача.
                </p>
                <p>
                    У цьому розділі ми розглянули агрегатні функції у MySQL, які дозволяють обчислювати статистичні
                    показники для груп рядків в таблиці. Використовуючи команду GROUP BY, ми можемо групувати рядки за
                    значенням певного стовпчика і застосовувати агрегатні функції до кожної групи. HAVING дозволяє нам
                    фільтрувати результати за значеннями обчислених агрегатних функцій.
                </p>
            </div>
            <div id="3.6">
                <h3>3.6 Скалярні функції</h3>
                <p>
                    У MySQL є багато скалярних функцій, які дозволяють працювати з рядками, числами та датами. Скалярні
                    функції повертають одне значення, що обчислюється на основі одного аргумента.
                </p>
                <p>
                    Один з найбільш поширених типів функцій - це функції рядкового типу. Ось декілька прикладів:
                </p>
                <p>
                    CONCAT() - дозволяє об'єднувати рядки в один:
                </p>
                <pre><code class="language-sql">
    SELECT CONCAT('Hello', ' ', 'World');
                </code></pre>
                <p>Результат: "Hello World".</p>
                <p>UPPER() та LOWER() - дозволяють перетворювати рядки в верхній або нижній регістр:</p>
                <pre><code class="language-sql">
    SELECT UPPER('hello'), LOWER('WORLD');
                </code></pre>
                <p>Результат: "HELLO", "world".</p>
                <p>TRIM() - видаляє пробіли на початку та в кінці рядка:</p>
                <pre><code class="language-sql">
    SELECT TRIM('   Hello   ');
                </code></pre>
                <p>Результат: "Hello".</p>
                <p>Серед числових функцій можна виділити такі:</p>
                <p>ABS() - повертає абсолютне значення числа:</p>
                <pre><code class="language-sql">
    SELECT ABS(-10);
                </code></pre>
                <p>Результат: 10.</p>
                <p>ROUND() - округлює число до заданої кількості знаків після коми:</p>
                <pre><code class="language-sql">
    SELECT ROUND(3.14159265, 2);
                </code></pre>
                <p>Результат: 3.14.</p>
                <p>RAND() - генерує випадкове число в діапазоні від 0 до 1:</p>
                <pre><code class="language-sql">
    SELECT RAND();
                </code></pre>
                <p>Результат: випадкове число в діапазоні від 0 до 1.</p>
                <p>У MySQL також є багато функцій, які дозволяють працювати з датами, наприклад:</p>
                <p>NOW() - повертає поточну дату та час:</p>
                <pre><code class="language-sql">
    SELECT NOW();
                </code></pre>
                <p>Результат: поточна дата та час.</p>
                <p>DATE() - витягує дату з дати та часу:</p>
                <pre><code class="language-sql">
    SELECT DATE(NOW());
                </code></pre>
                <p>Результат: поточна дата.</p>
                <p>DATEDIFF() - обчислює різницю між двома датами:</p>
                <pre><code class="language-sql">
    SELECT DATEDIFF('2023-03-21', '2022-03-21');
                </code></pre>
                <p>Результат: 365 (кількість днів між 21 березня 2022 року та 21 березня 2023 року).</p>
            </div>
        </div>
        <div id="4">
            <h2>4. Робота з MySQL</h2>
            <div id="4.1">
                <h3>4.1 Робота з MySQL з використанням інтерфейсу командного рядка</h3>
                <p>
                    Робота з MySQL з використанням інтерфейсу командного рядка є основним і найбільш простим способом
                    взаємодії з системою керування базами даних MySQL. Цей інтерфейс називається mysql client і
                    доступний для користувачів оперативної системи через термінал або командний рядок.
                </p>
                <p>
                    Для роботи з MySQL через командний рядок потрібно виконати наступні кроки:
                </p>
                <ul>
                    <li>Відкрийте термінал або командний рядок.</li>
                    <li>Запустіть інтерфейс командного рядка MySQL за допомогою команди:</li>
                </ul>
                <pre><code class="language-shell">
    mysql -u username -p
                </code></pre>
                <p>
                    де username - це ім'я користувача, який має доступ до бази даних MySQL. Після введення цієї команди
                    ви побачите запит на введення пароля.
                </p>
                <ul>
                    <li>
                        Після успішного входу ви отримаєте прийомний знак mysql>, що означає, що ви знаходитесь в
                        інтерфейсі командного рядка MySQL.
                    </li>
                    <li>
                        Тепер ви можете виконувати команди MySQL для роботи з базою даних, наприклад, створення таблиці:
                    </li>
                </ul>
                <pre><code class="language-sql">
    CREATE TABLE users (
       id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
       name VARCHAR(30) NOT NULL,
       email VARCHAR(50) NOT NULL
    );
                </code></pre>
                <ul>
                    <li>
                        Ви можете переглядати список доступних баз даних за допомогою команди:
                    </li>
                </ul>
                <pre><code class="language-sql">
    SHOW DATABASES;
                </code></pre>
                <ul>
                    <li>Щоб вибрати базу даних для роботи, виконайте команду:</li>
                </ul>
                <pre><code class="language-sql">
    USE database_name;
                </code></pre>
                <p>де database_name - це ім'я бази даних, з якою ви хочете працювати.</p>
                <ul>
                    <li>Для виходу з інтерфейсу командного рядка MySQL введіть команду:</li>
                </ul>
                <pre><code class="language-shell">
    exit;
                </code></pre>
                <p>або</p>
                <pre><code class="language-shell">
    quit;
                </code></pre>
                <p>
                    Також можна використовувати скорочену форму команди, наприклад, mysql -u username -p database_name,
                    яка дозволяє відразу виконувати команди в конкретній базі даних без необхідності вибирати базу даних
                    після запуску інтерфейсу командного рядка MySQL.
                </p>
            </div>
            <div id="4.2">
                <h3>4.2 Збереження та відновлення баз даних</h3>
                <p>
                    Щоб зберегти базу даних, необхідно створити її резервну копію (backup). Існує кілька способів
                    створення резервних копій, але одним з найпростіших є використання команди mysqldump.
                </p>
                <p>
                    Команда mysqldump дозволяє створювати резервні копії баз даних у вигляді SQL-скриптів. Ці скрипти
                    можуть бути використані для відновлення баз даних у разі потреби.
                </p>
                <p>
                    Ось приклад використання команди mysqldump для створення резервної копії бази даних:
                </p>
                <pre><code class="language-shell">
    mysqldump -u username -p dbname > backup.sql
                </code></pre>
                <p>
                    У цьому прикладі username - це ім'я користувача бази даних, dbname - назва бази даних, а backup.sql
                    - назва файлу, у який буде збережено резервну копію. Після введення цієї команди, MySQL створить
                    SQL-скрипт, який містить всі дані з бази даних, та збереже його у файлі backup.sql.
                </p>
                <p>
                    Для відновлення бази даних з резервної копії, необхідно виконати декілька кроків.
                </p>
                <p>
                    Створити нову базу даних з тією ж назвою, що й у резервній копії:
                </p>
                <pre><code class="language-sql">
    CREATE DATABASE dbname;
                </code></pre>
                <p>Завантажити резервну копію в нову базу даних:</p>
                <pre><code class="language-shell">
    mysql -u username -p dbname < backup.sql
                </code></pre>
                <p>
                    У цьому прикладі username - це ім'я користувача бази даних, dbname - назва бази даних, а backup.sql
                    - назва файлу з резервною копією, який було створено на попередньому етапі за допомогою команди
                    mysqldump. Після виконання цієї команди, MySQL відновить дані з резервної копії у нову базу даних.
                </p>
                <p>
                    Перевірити, чи були відновлені всі дані з бази даних.
                </p>
                <pre><code class="language-sql">
    USE dbname;
    SHOW TABLES;
                </code></pre>
                <p>
                    У цьому прикладі dbname - назва бази даних, яку ви створили на попередньому етапі. Команда SHOW
                    TABLES показує всі таблиці, які були відновлені з резервної копії.
                </p>
            </div>
            <div id="4.3">
                <h3>4.3 Відношення - OTO, OTM, MTM</h3>
                <p>4.3.1 One to one</p>
                <p>
                    Одне-до-одного (ОТО, або One-to-One) відношення в MySQL - це відношення між двома таблицями, в якому
                    кожен рядок однієї таблиці відповідає рівно одному рядку іншої таблиці.
                </p>
                <p>
                    Для створення ОТО відношення використовується первинний ключ (PRIMARY KEY) однієї таблиці, який
                    встановлюється як зовнішній ключ (FOREIGN KEY) в іншій таблиці.
                </p>
                <p>
                    Приклад:
                </p>
                <p>
                    Ми маємо дві таблиці: users та user_profiles. Кожен користувач має один профіль, і кожен профіль
                    належить лише одному користувачеві. Ось структура таблиць:
                </p>
                <p>
                    Таблиця users:
                </p>
                <pre><code class="language-sql">
    CREATE TABLE users (
        user_id INT AUTO_INCREMENT PRIMARY KEY,
        username VARCHAR(255) NOT NULL,
        email VARCHAR(255) NOT NULL UNIQUE
    );
                </code></pre>
                <p>Таблиця user_profiles:</p>
                <pre><code class="language-sql">
    CREATE TABLE user_profiles (
        profile_id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT UNIQUE,
        first_name VARCHAR(255),
        last_name VARCHAR(255),
        FOREIGN KEY (user_id) REFERENCES users(user_id)
    );
                </code></pre>
                <p>
                    Тут ми використовуємо user_id з таблиці users як зовнішній ключ у таблиці user_profiles. Атрибут
                    UNIQUE забезпечує, що кожен користувач матиме лише один профіль.
                </p>
                <p>
                    Давайте розглянемо, як додати користувача та профіль:
                </p>
                <pre><code class="language-sql">
    INSERT INTO users (username, email)
    VALUES ('john_doe', 'john@example.com');

    INSERT INTO user_profiles (user_id, first_name, last_name)
    VALUES (LAST_INSERT_ID(), 'John', 'Doe');
                </code></pre>
                <p>
                    Тут ми спочатку додаємо користувача, а потім додаємо профіль, використовуючи LAST_INSERT_ID() для
                    отримання user_id останнього доданого користувача.
                </p>
                <p>
                    Щоб отримати користувача та його профіль, використовуйте наступний запит:
                </p>
                <pre><code class="language-sql">
    SELECT users.*, user_profiles.first_name, user_profiles.last_name
    FROM users
    JOIN user_profiles ON users.user_id = user_profiles.user_id
    WHERE users.username = 'john_doe';
                </code></pre>
                <p>4.3.2 One to many</p>
                <p>
                    ОТM (One-to-Many) відношення є одним з найпоширеніших типів відношень у реляційних базах даних. Воно
                    відображає взаємозв'язок, коли один рядок з однієї таблиці може бути пов'язаний з декількома рядками
                    з іншої таблиці. Цей тип відношення створюється за допомогою зовнішнього ключа (Foreign Key) в
                    таблиці з багатьма (many) записами, який посилається на первинний ключ (Primary Key) таблиці з одним
                    (one) записом.
                </p>
                <p>
                    Розглянемо приклад бази даних для університету, де є таблиці "Викладачі" та "Студенти". Один
                    викладач може навчати кількох студентів, але кожен студент має лише одного куратора. Ось так може
                    виглядати структура таблиць:
                </p>
                <pre><code class="language-sql">
    CREATE TABLE Викладачі (
        id INT AUTO_INCREMENT PRIMARY KEY,
        ім'я VARCHAR(50) NOT NULL,
        прізвище VARCHAR(50) NOT NULL
    );

    CREATE TABLE Студенти (
        id INT AUTO_INCREMENT PRIMARY KEY,
        ім'я VARCHAR(50) NOT NULL,
        прізвище VARCHAR(50) NOT NULL,
        вік INT,
        викладач_id INT,
        FOREIGN KEY (викладач_id) REFERENCES Викладачі(id)
    );
                </code></pre>
                <p>
                    Додамо декілька викладачів і студентів:
                </p>
                <pre><code class="language-sql">
    INSERT INTO Викладачі (ім'я, прізвище) VALUES
    ('Іван', 'Петрович'),
    ('Ондрій', 'Сидорович');

    INSERT INTO Студенти (ім'я, прізвище, вік, викладач_id) VALUES
    ('Микола', 'Іванов', 20, 1),
    ('Олена', 'Миколаївна', 22, 1),
    ('Василь', 'Степанович', 21, 2);
                </code></pre>
                <p>
                    Тепер, якщо ми хочемо отримати інформацію про студентів та їхніх викладачів, ми можемо виконати
                    наступний запит:
                </p>
                <pre><code class="language-sql">
    SELECT Студенти.ім'я, Студенти.прізвище, Викладачі.ім'я AS викладач_ім'я, Викладачі.прізвище AS викладач_прізвище
    FROM Студенти
    JOIN Викладачі ON Студенти.викладач_id = Викладачі.id;
                </code></pre>
                <p>
                    Цей запит використовує JOIN для об'єднання таблиць "Студенти" та "Викладачі" на основі зовнішнього
                    ключа "викладач_id" та первинного ключа "id" відповідно. Результатом запиту буде такий вигляд:
                </p>
                <pre>
                    ім'я | прізвище | викладач_ім'я | викладач_прізвище
                    Микола | Іванов | Іван | Петрович
                    Олена | Миколаївна | Іван | Петрович
                    Василь | Степанович | Андрій | Сидорович
                </pre>
                <p>
                    Таким чином, ми успішно встановили відношення OТM між таблицями "Викладачі" та "Студенти". Зверніть
                    увагу, що відношення OТM не обмежується лише на одному рівні вкладеності. Наприклад, університет
                    може мати кілька факультетів, кожен з яких може мати кілька кафедр, і так далі. Головне правило для
                    створення таких відношень полягає в правильному використанні зовнішніх ключів та первинних ключів.
                </p>
                <p>4.3.3 Many to many</p>
                <p>
                    МТM (Many-to-Many) відношення є типом відношень, коли багато рядків з однієї таблиці можуть бути
                    пов'язані з багатьма рядками з іншої таблиці. Для створення таких відношень потрібно використовувати
                    допоміжну таблицю, яка зберігає зв'язки між рядками обох таблиць.
                </p>
                <p>
                    Розглянемо приклад з онлайн-бібліотекою, де є таблиці "Книги" та "Автори". Кожна книга може мати
                    декілька авторів, і кожен автор може мати декілька книг. Ось як ми можемо створити структуру
                    таблиць:
                </p>
                <pre><code class="language-sql">
    CREATE TABLE Книги (
        id INT AUTO_INCREMENT PRIMARY KEY,
        назва VARCHAR(100) NOT NULL
    );

    CREATE TABLE Автори (
        id INT AUTO_INCREMENT PRIMARY KEY,
        ім'я VARCHAR(50) NOT NULL,
        прізвище VARCHAR(50) NOT NULL
    );

    CREATE TABLE Книги_Автори (
        книга_id INT,
        автор_id INT,
        PRIMARY KEY (книга_id, автор_id),
        FOREIGN KEY (книга_id) REFERENCES Книги(id),
        FOREIGN KEY (автор_id) REFERENCES Автори(id)
    );
                </code></pre>
                <p>
                    Додамо декілька книг та авторів:
                </p>
                <pre><code class="language-sql">
    INSERT INTO Книги (назва) VALUES
    ('Книга 1'),
    ('Книга 2'),
    ('Книга 3');

    INSERT INTO Автори (ім'я, прізвище) VALUES
    ('Автор 1', 'Прізвище 1'),
    ('Автор 2', 'Прізвище 2');

    -- Встановлюємо зв'язки між книгами та авторами
    INSERT INTO Книги_Автори (книга_id, автор_id) VALUES
    (1, 1),
    (1, 2),
    (2, 1),
    (3, 2);
                </code></pre>
                <p>
                    Тепер, якщо ми хочемо отримати інформацію про книги та їхніх авторів, ми можемо виконати наступний
                    запит:
                </p>
                <pre><code class="language-sql">
    SELECT Книги.назва, Автори.ім'я, Автори.прізвище
    FROM Книги
    JOIN Книги_Автори ON Книги.id = Книги_Автори.книга_id
    JOIN Автори ON Автори.id = Книги_Автори.автор_id;
                </code></pre>
                <p>
                    Цей запит використовує JOIN для об'єднання таблиць "Книги", "Автори" та "Книги_Автори". Результатом
                    запиту буде такий вигляд:
                </p>
                <pre>
                    назва | ім'я | прізвище
                    Книга 1 | Автор 1 | Прізвище 1
                    Книга 1 | Автор 2 | Прізвище 2
                    Книга 2 | Автор 1 | Прізвище 1
                    Книга 3 | Автор 2 | Прізвище 2
                </pre>
                <p>
                    Таким чином, ми успішно встановили відношення МТМ між таблицями "Книги" та "Автори", використовуючи
                    допоміжну таблицю "Книги_Автори" для зберігання зв'язків між ними.
                    Цей підхід з використанням допоміжної таблиці можна застосовувати для створення відношень МТМ між
                    будь-якими таблицями. Головне правило полягає в правильному використанні зовнішніх ключів та
                    первинних ключів для створення зв'язків між рядками.
                </p>
            </div>
        </div>
        <div id="5">
            <h2>5. Розширені функції</h2>
            <div id="5.1">
                <h3>5.1 Процедури</h3>
                <div id="5.1.1">
                    <h4>5.1.1 Створення та виклик процедур</h4>
                    <div id="5.1.1.1">
                        <h5>5.1.1.1 Опис синтаксису для створення процедур (CREATE PROCEDURE)</h5>
                        <p>
                            Процедури є збереженими блоками коду, які виконуються на сервері баз даних. Вони дозволяють
                            інкапсулювати логіку, пов'язану з обробкою даних, та забезпечують більшу гнучкість і
                            швидкість роботи.
                        </p>
                        <p>
                            Для створення процедури в MySQL використовується команда CREATE PROCEDURE. Загальний
                            синтаксис виглядає наступним чином:
                        </p>
                        <pre><code class="language-sql">
    CREATE PROCEDURE назва_процедури ([параметр1 тип_даних, параметр2 тип_даних, ...])
    BEGIN
       -- тут розміщується тіло процедури
    END;
                        </code></pre>
                        <p>
                            Де:
                        </p>
                        <ul>
                            <li>назва_процедури - унікальна назва процедури в межах схеми бази даних;</li>
                            <li>
                                параметрN тип_даних - перелік параметрів процедури, якщо вони є, з вказівкою їх типу
                                даних.
                            </li>
                        </ul>
                        <p>Приклад створення простої процедури:</p>
                        <pre><code class="language-sql">
    DELIMITER //
    CREATE PROCEDURE ShowAllEmployees()
    BEGIN
       SELECT * FROM employees;
    END;
    //
    DELIMITER ;
                        </code></pre>
                        <p>
                            У цьому прикладі ми створюємо процедуру ShowAllEmployees, яка виводить всі записи з таблиці
                            "employees". Зверніть увагу на використання команди DELIMITER для зміни роздільника, щоб
                            сервер коректно сприймав кінцевий символ блоку коду процедури.
                        </p>
                    </div>
                    <div id="5.1.1.2">
                        <h5>5.1.1.2 Використання IN, OUT та INOUT параметрів</h5>
                        <p>
                            Процедури можуть приймати параметри, які передаються при виклику процедури. У MySQL є три
                            типи параметрів: IN, OUT та INOUT.
                        </p>
                        <ul>
                            <li>
                                IN: Це значення передається в процедуру ззовні. Воно є аргументом процедури та є
                                доступним тільки для читання в межах процедури. Значення параметра IN не може бути
                                змінено в процедурі.
                            </li>
                            <li>
                                OUT: Це значення, яке повертається процедурою. Значення параметра OUT встановлюється
                                всередині процедури та може бути використано після виклику процедури.
                            </li>
                            <li>
                                INOUT: Це комбінація IN та OUT параметрів. Значення INOUT передається в процедуру та
                                може бути змінено в межах процедури. Змінене значення параметра INOUT повертається після
                                виклику процедури.
                            </li>
                        </ul>
                        <p>
                            Синтаксис визначення параметрів:
                        </p>
                        <pre><code class="language-sql">
    CREATE PROCEDURE назва_процедури (IN параметр1 тип_даних, OUT параметр2 тип_даних, INOUT параметр3 тип_даних)
                        </code></pre>
                        <p>
                            Приклад процедури з параметрами IN, OUT та INOUT:
                        </p>
                        <pre><code class="language-sql">
    DELIMITER //
    CREATE PROCEDURE CalculateArea(IN radius DOUBLE, OUT area DOUBLE, INOUT circumference DOUBLE)
    BEGIN
       SET area = PI() * POW(radius, 2);
       SET circumference = 2 * PI() * radius;
    END;
    //
    DELIMITER ;
                        </code></pre>
                        <p>
                            У цьому прикладі створюється процедура CalculateArea, яка приймає радіус кола (параметр IN),
                            обчислює площу кола (параметр OUT) та обчислює та повертає довжину окружності (параметр
                            INOUT).
                        </p>
                    </div>
                    <div id="5.1.1.3">
                        <h5>5.1.1.3 Виклик процедур за допомогою команди CALL</h5>
                        <p></p>
                        <p></p>
                    </div>
                    <div id="5.1.1.4">
                        <h5>5.1.1.4 Приклад коду для створення та виклику процедури</h5>
                        <p></p>
                        <p></p>
                    </div>
                </div>
                <div id="5.1.2">
                    <h4>5.1.2 Контроль потоку в процедурах</h4>
                    <div id="5.1.2.1">
                        <h5>5.1.2.1 Використання IF, CASE, LOOP, WHILE та REPEAT конструкцій</h5>
                        <p></p>
                        <p></p>
                    </div>
                    <div id="5.1.2.2">
                        <h5>5.1.2.2 Синтаксис та приклади коду для кожної конструкції</h5>
                        <p></p>
                        <p></p>
                    </div>
                </div>
                <div id="5.1.3">
                    <h4>5.1.3 Обробка помилок та ексепшнів в процедурах</h4>
                    <div id="5.1.3.1">
                        <h5>5.1.3.1 Оголошення та використання обробників помилок (DECLARE HANDLER)</h5>
                        <p></p>
                        <p></p>
                    </div>
                    <div id="5.1.3.2">
                        <h5>5.1.3.2 Типи обробників: CONTINUE, EXIT та UNDO</h5>
                        <p></p>
                        <p></p>
                    </div>
                    <div id="5.1.3.3">
                        <h5>5.1.3.3 Використання SIGNAL та RESIGNAL для генерації та пропагації помилок</h5>
                        <p></p>
                        <p></p>
                    </div>
                    <div id="5.1.3.4">
                        <h5>5.1.3.4 Приклади коду для обробки помилок та ексепшнів</h5>
                        <p></p>
                        <p></p>
                    </div>
                </div>
            </div>
            <div id="5.2">
                <h3>5.2 View</h3>
                <p></p>
                <p></p>
                <p></p>
            </div>
            <div id="5.3">
                <h3>5.3 Тригери</h3>
                <p></p>
                <p></p>
                <p></p>
            </div>
            <div id="5.4">
                <h3>5.4 Привілеї. GRANT, REVOKE</h3>
                <p></p>
                <p></p>
                <p></p>
            </div>
            <div id="5.5">
                <h3>5.5 Нормалізація</h3>
                <p></p>
                <p></p>
                <p></p>
            </div>
        </div>
    </div>
</div>
<script src="../../script.js"></script>
</body>
</html>

<pre><code class="language-sql">
</code></pre>

Ти асистент викладача-програміста.
Намагайся уникати "теоретичної води", більше зосередься на практичних знаннях. Не лишнім будуть приклади коду.

Контекст:
Я пишу матеріал для лекції по MySQL.
Зараз на етапі написання розділу "5. Розширені функції" та підрозділу "5.1 Процедури".
Зараз ми на етапі пункту "5.1.1 Створення та виклик процедур"

Тепер завдання:
Напиши мені підпункт "5.1.1.3 Виклик процедур за допомогою команди CALL"
