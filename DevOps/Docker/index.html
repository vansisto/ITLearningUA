<!DOCTYPE html>
<html lang="ua">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker - ITLearningUA</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jura:wght@300..700&family=VT323&display=swap" rel="stylesheet">
    <link href="../../style.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</head>
<body>
    <header>
        <nav class="container">
            <a href="../../index.html" class="logo">ITLearningUA</a>
            <ul class="nav-links">
                <li><a href="../../index.html">Головна</a></li>
                <li><a href="../index.html">DevOps</a></li>
            </ul>
        </nav>
    </header>

    <section class="article-header">
        <div class="container">
            <div class="breadcrumb">
                <a href="../../index.html">Головна</a> / <a href="../index.html">DevOps</a> / Docker
            </div>
            
            <h1 class="article-title">Docker</h1>
            <div class="article-meta">
                <span>DevOps</span>
                <span>Контейнеризація</span>
                <span>Docker</span>
            </div>
            <div class="article-tag">Повний курс</div>
            <p class="article-description">
                Комплексне вивчення Docker - від основ контейнеризації до оркестрації, безпеки та production deployment
            </p>
        </div>
    </section>

    <div class="container">
        <div class="main-content">
            <aside class="table-of-contents">
                <h3 class="toc-title">Зміст</h3>
                <ul class="toc-list">
                    <li class="toc-section">
                        <a href="#1" class="toc-h2">1. Що таке Docker?</a>
                        <ul>
                            <li class="toc-subsection">
                                <a href="#1.1" class="toc-h3">1.1 Знайомство з контейнерами</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#1.2" class="toc-h3">1.2 Встановлення Docker</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#1.3" class="toc-h3">1.3 Перший контейнер</a>
                            </li>
                        </ul>
                    </li>
                    <li class="toc-section">
                        <a href="#2" class="toc-h2">2. Основні команди Docker</a>
                        <ul>
                            <li class="toc-subsection">
                                <a href="#2.1" class="toc-h3">2.1 Запуск контейнерів</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#2.2" class="toc-h3">2.2 Управління контейнерами</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#2.3" class="toc-h3">2.3 Робота з образами</a>
                            </li>
                        </ul>
                    </li>
                    <li class="toc-section">
                        <a href="#3" class="toc-h2">3. Створення власних образів</a>
                        <ul>
                            <li class="toc-subsection">
                                <a href="#3.1" class="toc-h3">3.1 Основи Dockerfile</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#3.2" class="toc-h3">3.2 Збірка образів</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#3.3" class="toc-h3">3.3 Практичні приклади</a>
                            </li>
                        </ul>
                    </li>
                    <li class="toc-section">
                        <a href="#4" class="toc-h2">4. Підключення портів та папок</a>
                        <ul>
                            <li class="toc-subsection">
                                <a href="#4.1" class="toc-h3">4.1 Робота з портами</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#4.2" class="toc-h3">4.2 Монтування папок</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#4.3" class="toc-h3">4.3 Збереження даних</a>
                            </li>
                        </ul>
                    </li>
                    <li class="toc-section">
                        <a href="#5" class="toc-h2">5. Docker Compose</a>
                        <ul>
                            <li class="toc-subsection">
                                <a href="#5.1" class="toc-h3">5.1 Що таке Docker Compose</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#5.2" class="toc-h3">5.2 Перший docker-compose.yml</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#5.3" class="toc-h3">5.3 Практичні приклади</a>
                            </li>
                        </ul>
                    </li>
                    <li class="toc-section">
                        <a href="#6" class="toc-h2">6. Мережі в Docker</a>
                        <ul>
                            <li class="toc-subsection">
                                <a href="#6.1" class="toc-h3">6.1 Основи мереж</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#6.2" class="toc-h3">6.2 З'єднання контейнерів</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#6.3" class="toc-h3">6.3 Створення власних мереж</a>
                            </li>
                        </ul>
                    </li>
                    <li class="toc-section">
                        <a href="#7" class="toc-h2">7. Практичні проекти</a>
                        <ul>
                            <li class="toc-subsection">
                                <a href="#7.1" class="toc-h3">7.1 Веб-додаток з базою даних</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#7.2" class="toc-h3">7.2 WordPress сайт</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#7.3" class="toc-h3">7.3 API з Redis</a>
                            </li>
                        </ul>
                    </li>
                    <li class="toc-section">
                        <a href="#8" class="toc-h2">8. Розгортання в продакшні</a>
                        <ul>
                            <li class="toc-subsection">
                                <a href="#8.1" class="toc-h3">8.1 Підготовка до продакшну</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#8.2" class="toc-h3">8.2 Хмарні платформи</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#8.3" class="toc-h3">8.3 Моніторинг та логи</a>
                            </li>
                        </ul>
                    </li>
                    <li class="toc-section">
                        <a href="#9" class="toc-h2">9. Просунуті теми</a>
                        <ul>
                            <li class="toc-subsection">
                                <a href="#9.1" class="toc-h3">9.1 Безпека контейнерів</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#9.2" class="toc-h3">9.2 CI/CD з Docker</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#9.3" class="toc-h3">9.3 Docker Swarm</a>
                            </li>
                            <li class="toc-subsection">
                                <a href="#9.4" class="toc-h3">9.4 Kubernetes вступ</a>
                            </li>
                        </ul>
                    </li>
                </ul>
            </aside>

            <article class="article-content">
                <div id="1">
                    <h2 id="1">1. Що таке Docker?</h2>
                    
                    <div id="1.1">
                        <h3 id="1.1">1.1 Знайомство з контейнерами</h3>
                        
                        <p>Docker - це платформа для контейнеризації застосунків, яка дозволяє упаковувати програми разом із усіма їх залежностями в легкі, портативні контейнери.</p>

                        <h4>Що таке контейнер?</h4>
                        <p>Контейнер - це стандартизована одиниця програмного забезпечення, яка містить код додатку та всі необхідні для його роботи компоненти:</p>
                        <ul>
                            <li>Код застосунку</li>
                            <li>Системні бібліотеки</li>
                            <li>Інструменти та утиліти</li>
                            <li>Змінні оточення</li>
                            <li>Файли конфігурації</li>
                        </ul>

                        <h4>Основні переваги контейнерів:</h4>
                        <ul>
                            <li><strong>Портативність</strong> - працює однаково на різних системах</li>
                            <li><strong>Ізоляція</strong> - додатки не конфліктують між собою</li>
                            <li><strong>Ефективність</strong> - швидкий запуск та менше ресурсів</li>
                            <li><strong>Масштабованість</strong> - легко створювати копії</li>
                            <li><strong>Консистентність</strong> - однакове середовище скрізь</li>
                        </ul>

                        <div class="info-box">
                            <div class="info-box-title">💡 Простий приклад</div>
                            <p>Уявіть, що ваш додаток - це готова страва, а контейнер - це ланч-бокс із усім необхідним (страва, столові прилади, серветки). Ви можете взяти цей ланч-бокс куди завгодно і скрізь отримаєте той самий результат.</p>
                        </div>

                        <h4>Контейнери vs Віртуальні машини</h4>
                        <p>Основна відмінність між контейнерами та віртуальними машинами:</p>
                        
                        <div class="code-block">
                            <strong>Віртуальні машини:</strong>
                            [Апаратне забезпечення] → [Операційна система] → [Гіпервізор] → [VM1] → [OS1] → [Додаток1]
                                                                                     → [VM2] → [OS2] → [Додаток2]
                            <br/>
                            <strong>Контейнери:</strong>
                            [Апаратне забезпечення] → [Операційна система] → [Docker Engine] → [Контейнер1] → [Додаток1]
                                                                                           → [Контейнер2] → [Додаток2]
                        </div>

                        <p><strong>Переваги контейнерів над VM:</strong></p>
                        <ul>
                            <li>Менше споживання ресурсів</li>
                            <li>Швидший запуск (секунди vs хвилини)</li>
                            <li>Вища щільність розгортання</li>
                            <li>Простіше управління</li>
                        </ul>
                    </div>

                    <div id="1.2">
                        <h3 id="1.2">1.2 Встановлення Docker</h3>
                        
                        <p>Docker можна встановити на різних операційних системах. Розглянемо найпоширеніші варіанти.</p>

                        <h4>Windows</h4>
                        <p>Для Windows рекомендується використовувати Docker Desktop:</p>
                        <ol>
                            <li>Перейдіть на <a href="https://www.docker.com/products/docker-desktop">офіційний сайт Docker</a></li>
                            <li>Завантажте Docker Desktop для Windows</li>
                            <li>Запустіть інсталятор та дотримуйтесь інструкцій</li>
                            <li>Після встановлення перезавантажте комп'ютер</li>
                        </ol>

                        <div class="info-box warning">
                            <div class="info-box-title">⚠️ Системні вимоги для Windows</div>
                            <p>Docker Desktop потребує Windows 10/11 Pro/Enterprise або Windows 10/11 Home з увімкненим WSL 2.</p>
                        </div>

                        <h4>macOS</h4>
                        <p>Для macOS також використовується Docker Desktop:</p>
                        <ol>
                            <li>Завантажте Docker Desktop для Mac</li>
                            <li>Перетягніть Docker.app до папки Applications</li>
                            <li>Запустіть Docker з папки Applications</li>
                            <li>Дотримуйтесь підказок для завершення налаштування</li>
                        </ol>

                        <h4>Linux (Ubuntu/Debian)</h4>
                        <p>На Linux Docker встановлюється через пакетний менеджер:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Оновлення індексу пакетів
sudo apt update

# Встановлення залежностей
sudo apt install apt-transport-https ca-certificates curl gnupg lsb-release

# Додавання GPG ключа Docker
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# Додавання репозиторію Docker
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# Встановлення Docker
sudo apt update
sudo apt install docker-ce docker-ce-cli containerd.io

# Додавання користувача до групи docker (щоб не використовувати sudo)
sudo usermod -aG docker $USER</code></pre>
                        </div>

                        <h4>Перевірка встановлення</h4>
                        <p>Після встановлення перевірте, чи працює Docker:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Перевірка версії Docker
docker --version

# Запуск тестового контейнера
docker run hello-world</code></pre>
                        </div>

                        <p>Якщо все встановлено правильно, ви побачите привітальне повідомлення від Docker.</p>
                    </div>

                    <div id="1.3">
                        <h3 id="1.3">1.3 Перший контейнер</h3>
                        
                        <p>Тепер, коли Docker встановлено, запустимо наш перший контейнер та розберемо основні концепції.</p>

                        <h4>Запуск hello-world</h4>
                        <p>Найпростіший спосіб перевірити Docker - запустити офіційний тестовий контейнер:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash">docker run hello-world</code></pre>
                        </div>

                        <p>Ця команда:</p>
                        <ol>
                            <li>Шукає образ "hello-world" локально</li>
                            <li>Якщо не знаходить - завантажує з Docker Hub</li>
                            <li>Створює контейнер з цього образу</li>
                            <li>Запускає контейнер</li>
                            <li>Показує привітальне повідомлення</li>
                            <li>Контейнер завершує роботу</li>
                        </ol>

                        <h4>Запуск веб-сервера</h4>
                        <p>Спробуємо щось більш практичне - запустимо простий веб-сервер:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Запуск Nginx веб-сервера
docker run -d -p 8080:80 --name my-nginx nginx

# -d: запуск у фоновому режимі
# -p 8080:80: прокидування порту 8080 на 80
# --name: присвоєння імені контейнеру
# nginx: назва образу</code></pre>
                        </div>

                        <p>Тепер відкрийте браузер і перейдіть за адресою <code>http://localhost:8080</code>. Ви побачите привітальну сторінку Nginx!</p>

                        <h4>Основні команди для роботи з контейнерами</h4>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Переглянути запущені контейнери
docker ps

# Переглянути всі контейнери (включно зі зупиненими)
docker ps -a

# Зупинити контейнер
docker stop my-nginx

# Запустити зупинений контейнер
docker start my-nginx

# Видалити контейнер
docker rm my-nginx

# Видалити контейнер примусово (якщо він запущений)
docker rm -f my-nginx</code></pre>
                        </div>

                        <h4>Основні поняття</h4>
                        <p>Розберемо ключові терміни Docker:</p>
                        <ul>
                            <li><strong>Образ (Image)</strong> - шаблон для створення контейнерів, незмінний</li>
                            <li><strong>Контейнер (Container)</strong> - запущений екземпляр образу</li>
                            <li><strong>Docker Hub</strong> - хмарний реєстр образів</li>
                            <li><strong>Dockerfile</strong> - текстовий файл з інструкціями для збірки образу</li>
                            <li><strong>Порт (Port)</strong> - точка доступу до контейнера ззовні</li>
                        </ul>
                    </div>
                </div>

                <div id="2">
                    <h2 id="2">2. Основні команди Docker</h2>
                    
                    <div id="2.1">
                        <h3 id="2.1">2.1 Запуск контейнерів</h3>
                        
                        <p>Команда <code>docker run</code> - це основа роботи з Docker. Вона дозволяє створити та запустити новий контейнер з образу.</p>

                        <h4>Базовий синтаксис</h4>
                        <div class="code-block">
                            <pre><code class="language-bash">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></pre>
                        </div>

                        <h4>Найпростіший приклад</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Запустити Ubuntu контейнер та виконати команду echo
docker run ubuntu echo "Привіт з контейнера!"

# Запустити інтерактивний режим Ubuntu
docker run -it ubuntu bash

# -i: інтерактивний режим (STDIN відкритий)
# -t: псевдо-TTY (емуляція терміналу)</code></pre>
                        </div>

                        <h4>Основні опції команди run</h4>
                        <ul>
                            <li><code>-d, --detach</code> - запуск у фоновому режимі</li>
                            <li><code>-i, --interactive</code> - інтерактивний режим</li>
                            <li><code>-t, --tty</code> - виділення псевдо-TTY</li>
                            <li><code>--name</code> - присвоєння імені контейнеру</li>
                            <li><code>-p, --publish</code> - прокидування портів</li>
                            <li><code>-v, --volume</code> - монтування томів</li>
                            <li><code>--rm</code> - автоматичне видалення після завершення</li>
                        </ul>

                        <h4>Практичні приклади запуску</h4>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Запуск веб-сервера Apache у фоновому режимі
docker run -d -p 8080:80 --name my-apache httpd

# Запуск MySQL бази даних з змінними оточення
docker run -d --name my-mysql -e MYSQL_ROOT_PASSWORD=mypassword mysql

# Запуск Node.js додатку з монтуванням локальної папки
docker run -d -p 3000:3000 -v $(pwd):/app --name my-node-app node

# Запуск тимчасового контейнера, який видалиться після завершення
docker run --rm -it alpine sh</code></pre>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">💡 Порада</div>
                            <p>Використовуйте <code>--rm</code> для тестових контейнерів, щоб вони автоматично видалялися після роботи і не засмічували систему.</p>
                        </div>

                        <h4>Запуск з командою</h4>
                        <p>Ви можете перевизначити команду, яка виконується в контейнері:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Замість стандартної команди виконати ls
docker run ubuntu ls -la

# Запустити Python скрипт
docker run python:3.9 python -c "print('Hello from Python!')"

# Запустити curl для перевірки сайту
docker run --rm curlimages/curl curl -s https://httpbin.org/ip</code></pre>
                        </div>
                    </div>

                    <div id="2.2">
                        <h3 id="2.2">2.2 Управління контейнерами</h3>
                        
                        <p>Після створення контейнерів важливо вміти ними управляти: зупиняти, запускати, перезапускати та видаляти.</p>

                        <h4>Перегляд контейнерів</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Переглянути запущені контейнери
docker ps

# Переглянути всі контейнери (включно зі зупиненими)
docker ps -a

# Показати тільки ID контейнерів
docker ps -q

# Показати останні 3 контейнери
docker ps -n 3</code></pre>
                        </div>

                        <h4>Управління життєвим циклом</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Зупинити контейнер (graceful shutdown)
docker stop my-nginx

# Примусово зупинити контейнер
docker kill my-nginx

# Запустити зупинений контейнер
docker start my-nginx

# Перезапустити контейнер
docker restart my-nginx

# Призупинити контейнер (pause)
docker pause my-nginx

# Відновити призупинений контейнер
docker unpause my-nginx</code></pre>
                        </div>

                        <h4>Видалення контейнерів</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Видалити зупинений контейнер
docker rm my-nginx

# Примусово видалити запущений контейнер
docker rm -f my-nginx

# Видалити всі зупинені контейнери
docker container prune

# Видалити контейнер після зупинки
docker rm $(docker ps -aq --filter "status=exited")</code></pre>
                        </div>

                        <h4>Взаємодія з контейнерами</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Виконати команду в запущеному контейнері
docker exec my-nginx ls /etc

# Підключитися до запущеного контейнера інтерактивно
docker exec -it my-nginx bash

# Скопіювати файл з контейнера на хост
docker cp my-nginx:/etc/nginx/nginx.conf ./nginx.conf

# Скопіювати файл з хоста в контейнер
docker cp ./index.html my-nginx:/usr/share/nginx/html/</code></pre>
                        </div>

                        <h4>Моніторинг контейнерів</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Переглянути логи контейнера
docker logs my-nginx

# Переглянути логи в реальному часі
docker logs -f my-nginx

# Переглянути останні 50 рядків логів
docker logs --tail 50 my-nginx

# Статистика використання ресурсів
docker stats

# Статистика конкретного контейнера
docker stats my-nginx</code></pre>
                        </div>

                        <div class="info-box warning">
                            <div class="info-box-title">⚠️ Важливо</div>
                            <p>Зупинка контейнера не видаляє його. Для повного видалення використовуйте <code>docker rm</code>. Дані в контейнері зберігаються до його видалення.</p>
                        </div>
                    </div>

                    <div id="2.3">
                        <h3 id="2.3">2.3 Робота з образами</h3>
                        
                        <p>Образи - це шаблони для створення контейнерів. Розберемо, як завантажувати, переглядати та управляти ними.</p>

                        <h4>Завантаження образів</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Завантажити образ з Docker Hub
docker pull nginx

# Завантажити конкретну версію образу
docker pull nginx:1.21

# Завантажити образ з іншого реєстру
docker pull ghcr.io/nginx/nginx:latest</code></pre>
                        </div>

                        <h4>Перегляд образів</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Показати всі локальні образи
docker images

# Показати тільки ID образів
docker images -q

# Фільтрувати образи за назвою
docker images nginx

# Показати образи з розміром
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"</code></pre>
                        </div>

                        <h4>Детальна інформація про образ</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Детальна інформація про образ
docker inspect nginx

# Переглянути історію створення образу
docker history nginx

# Переглянути шари образу
docker image inspect nginx --format='{{.RootFS.Layers}}'</code></pre>
                        </div>

                        <h4>Теги та версії</h4>
                        <p>Docker використовує систему тегів для позначення версій образів:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Популярні теги:
# latest - остання версія (за замовчуванням)
# alpine - мінімальна версія на базі Alpine Linux
# slim - зменшена версія
# 1.21, 1.21.1 - конкретні версії

# Приклади:
docker pull nginx:latest    # остання версія
docker pull nginx:alpine   # Alpine версія
docker pull python:3.9     # Python версії 3.9
docker pull node:16-slim   # Node.js версії 16, slim варіант</code></pre>
                        </div>

                        <h4>Створення власних тегів</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Створити новий тег для існуючого образу
docker tag nginx:latest my-nginx:v1.0

# Перейменування образу
docker tag ubuntu:20.04 mycompany/ubuntu:production</code></pre>
                        </div>

                        <h4>Видалення образів</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Видалити образ
docker rmi nginx

# Видалити образ за ID
docker rmi abc123def456

# Примусово видалити образ (навіть якщо використовується)
docker rmi -f nginx

# Видалити всі невикористовувані образи
docker image prune

# Видалити всі образи
docker rmi $(docker images -q)</code></pre>
                        </div>

                        <h4>Пошук образів</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Пошук образів на Docker Hub
docker search nginx

# Пошук офіційних образів
docker search --filter is-official=true nginx

# Пошук з мінімальним рейтингом
docker search --filter stars=50 nginx</code></pre>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">🎯 Практичне завдання</div>
                            <p>Спробуйте:</p>
                            <ol>
                                <li>Завантажити образ <code>hello-world</code></li>
                                <li>Запустити контейнер з іменем "test"</li>
                                <li>Переглянути логи контейнера</li>
                                <li>Видалити контейнер та образ</li>
                            </ol>
                        </div>

                        <h4>Корисні поради</h4>
                        <ul>
                            <li>Завжди вказуйте конкретну версію образу в продакшні</li>
                            <li>Віддавайте перевагу офіційним образам</li>
                            <li>Використовуйте Alpine версії для зменшення розміру</li>
                            <li>Регулярно очищуйте невикористовувані образи</li>
                            <li>Перевіряйте безпеку образів перед використанням</li>
                        </ul>
                    </div>
                </div>

                <div id="3">
                    <h2 id="3">3. Створення власних образів</h2>
                    
                    <div id="3.1">
                        <h3 id="3.1">3.1 Основи Dockerfile</h3>
                        
                        <p>Dockerfile - це текстовий файл з інструкціями для автоматичної збірки Docker образів. Це рецепт, який описує, як створити ваш власний образ.</p>

                        <h4>Структура Dockerfile</h4>
                        <p>Dockerfile складається з інструкцій, кожна з яких створює новий шар в образі:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Коментар
ІНСТРУКЦІЯ аргументи</code></pre>
                        </div>

                        <h4>Основні інструкції</h4>
                        
                        <p><strong>FROM</strong> - базовий образ (обов'язкова, перша інструкція)</p>
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Використати офіційний Ubuntu образ
FROM ubuntu:20.04

# Використати Python образ
FROM python:3.9

# Використати мінімальний Alpine образ
FROM alpine:latest</code></pre>
                        </div>

                        <p><strong>RUN</strong> - виконати команду під час збірки</p>
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Оновити пакети та встановити nginx
RUN apt-get update && apt-get install -y nginx

# Встановити Python бібліотеки
RUN pip install flask requests

# Створити директорію
RUN mkdir -p /app/data</code></pre>
                        </div>

                        <p><strong>COPY</strong> - скопіювати файли з хоста в образ</p>
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Скопіювати файл
COPY app.py /app/

# Скопіювати всі файли з поточної директорії
COPY . /app/

# Скопіювати з вказанням власника
COPY --chown=1000:1000 config.json /etc/</code></pre>
                        </div>

                        <p><strong>WORKDIR</strong> - встановити робочу директорію</p>
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Встановити робочу директорію
WORKDIR /app

# Всі наступні команди будуть виконуватися в /app</code></pre>
                        </div>

                        <p><strong>EXPOSE</strong> - вказати порт, який використовує додаток</p>
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Відкрити порт 80
EXPOSE 80

# Відкрити кілька портів
EXPOSE 8000 8080</code></pre>
                        </div>

                        <p><strong>CMD</strong> - команда за замовчуванням для запуску контейнера</p>
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Запустити Python скрипт
CMD ["python", "app.py"]

# Запустити nginx
CMD ["nginx", "-g", "daemon off;"]

# Shell форма (не рекомендується)
CMD python app.py</code></pre>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">💡 Відмінність CMD vs RUN</div>
                            <p><strong>RUN</strong> виконується під час збірки образу і створює новий шар.<br/>
                            <strong>CMD</strong> виконується при запуску контейнера і може бути перевизначена.</p>
                        </div>

                        <h4>Перший Dockerfile</h4>
                        <p>Створимо простий Dockerfile для веб-додатку:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Використовуємо офіційний Python образ
FROM python:3.9-slim

# Встановлюємо робочу директорію
WORKDIR /app

# Копіюємо файл з залежностями
COPY requirements.txt .

# Встановлюємо залежності
RUN pip install -r requirements.txt

# Копіюємо код додатку
COPY . .

# Відкриваємо порт
EXPOSE 5000

# Запускаємо додаток
CMD ["python", "app.py"]</code></pre>
                        </div>

                        <h4>Змінні оточення</h4>
                        <p><strong>ENV</strong> - встановити змінні оточення</p>
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Встановити змінну
ENV APP_ENV=production

# Встановити кілька змінних
ENV DATABASE_URL=postgresql://localhost/mydb \
    DEBUG=false \
    PORT=5000</code></pre>
                        </div>

                        <h4>Користувач та права</h4>
                        <p><strong>USER</strong> - встановити користувача для виконання команд</p>
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Створити користувача та групу
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Змінити власника файлів
RUN chown -R appuser:appuser /app

# Переключитися на користувача
USER appuser</code></pre>
                        </div>

                        <div class="info-box warning">
                            <div class="info-box-title">⚠️ Безпека</div>
                            <p>Не запускайте додатки від root у продакшні. Завжди створюйте окремого користувача для додатку.</p>
                        </div>
                    </div>

                    <div id="3.2">
                        <h3 id="3.2">3.2 Збірка образів</h3>
                        
                        <p>Після створення Dockerfile потрібно зібрати з нього образ за допомогою команди <code>docker build</code>.</p>

                        <h4>Основи збірки</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Зібрати образ з поточної директорії
docker build .

# Зібрати з тегом
docker build -t my-app:1.0 .

# Зібрати з іншого Dockerfile
docker build -f Dockerfile.dev -t my-app:dev .

# Зібрати з віддаленого git репозиторію
docker build https://github.com/user/repo.git</code></pre>
                        </div>

                        <h4>Контекст збірки</h4>
                        <p>Крапка в кінці команди вказує контекст збірки - директорію, яка надсилається Docker daemon'у:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Контекст - поточна директорія
docker build -t my-app .

# Контекст - батьківська директорія
docker build -t my-app ..

# Контекст - конкретна директорія
docker build -t my-app /path/to/context</code></pre>
                        </div>

                        <h4>.dockerignore файл</h4>
                        <p>Файл <code>.dockerignore</code> дозволяє виключити файли з контексту збірки:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-plaintext"># .dockerignore
node_modules
*.log
.git
.gitignore
README.md
Dockerfile
.dockerignore
tmp/
*.tmp</code></pre>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">💡 Порада</div>
                            <p>Використовуйте .dockerignore для зменшення розміру контексту збірки. Це прискорює процес та зменшує розмір образу.</p>
                        </div>

                        <h4>Кешування шарів</h4>
                        <p>Docker кешує шари образу. Розміщуйте інструкції, які рідко змінюються, на початку Dockerfile:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># ✅ Правильно - залежності рідко змінюються
FROM python:3.9
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD ["python", "app.py"]

# ❌ Неправильно - код змінюється часто
FROM python:3.9
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
CMD ["python", "app.py"]</code></pre>
                        </div>

                        <h4>Аргументи збірки</h4>
                        <p><strong>ARG</strong> - змінні, які можна передати під час збірки</p>
                        
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Dockerfile
ARG PYTHON_VERSION=3.9
FROM python:${PYTHON_VERSION}

ARG APP_VERSION=1.0
LABEL version=${APP_VERSION}</code></pre>
                        </div>

                        <div class="code-block">
                            <pre><code class="language-bash"># Передати аргументи при збірці
docker build --build-arg PYTHON_VERSION=3.10 --build-arg APP_VERSION=2.0 -t my-app .</code></pre>
                        </div>

                        <h4>Мульти-стадійна збірка</h4>
                        <p>Дозволяє використовувати кілька базових образів в одному Dockerfile:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Стадія збірки
FROM node:16 AS builder
WORKDIR /app
COPY package.json .
RUN npm install
COPY . .
RUN npm run build

# Продакшн стадія
FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]</code></pre>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">🎯 Переваги мульти-стадійної збірки</div>
                            <ul>
                                <li>Менший розмір фінального образу</li>
                                <li>Відсутність інструментів збірки в продакшн образі</li>
                                <li>Кращий поділ між dev та prod середовищами</li>
                            </ul>
                        </div>
                    </div>

                    <div id="3.3">
                        <h3 id="3.3">3.3 Практичні приклади</h3>
                        
                        <p>Розглянемо реальні приклади створення образів для різних типів додатків.</p>

                        <h4>Python Flask додаток</h4>
                        <p>Створимо простий веб-додаток на Flask:</p>
                        
                        <p><strong>app.py</strong></p>
                        <div class="code-block">
                            <pre><code class="language-python">from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello():
    return 'Привіт з Docker контейнера!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)</code></pre>
                        </div>

                        <p><strong>requirements.txt</strong></p>
                        <div class="code-block">
                            <pre><code class="language-plaintext">Flask==2.3.3</code></pre>
                        </div>

                        <p><strong>Dockerfile</strong></p>
                        <div class="code-block">
                            <pre><code class="language-dockerfile">FROM python:3.9-slim

# Встановити системні залежності
RUN apt-get update && apt-get install -y \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# Створити користувача
RUN useradd -m -u 1000 appuser

WORKDIR /app

# Скопіювати та встановити залежності
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Скопіювати код додатку
COPY app.py .

# Змінити власника файлів
RUN chown -R appuser:appuser /app

# Переключитися на користувача
USER appuser

EXPOSE 5000

CMD ["python", "app.py"]</code></pre>
                        </div>

                        <p><strong>Збірка та запуск:</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Зібрати образ
docker build -t flask-app .

# Запустити контейнер
docker run -d -p 5000:5000 --name my-flask-app flask-app

# Перевірити
curl http://localhost:5000</code></pre>
                        </div>

                        <h4>Node.js додаток</h4>
                        <p><strong>package.json</strong></p>
                        <div class="code-block">
                            <pre><code class="language-json">{
  "name": "node-docker-app",
  "version": "1.0.0",
  "main": "server.js",
  "dependencies": {
    "express": "^4.18.0"
  },
  "scripts": {
    "start": "node server.js"
  }
}</code></pre>
                        </div>

                        <p><strong>server.js</strong></p>
                        <div class="code-block">
                            <pre><code class="language-javascript">const express = require('express');
const app = express();
const PORT = process.env.PORT || 3000;

app.get('/', (req, res) => {
    res.send('Node.js додаток в Docker!');
});

app.listen(PORT, () => {
    console.log(`Сервер запущено на порту ${PORT}`);
});</code></pre>
                        </div>

                        <p><strong>Dockerfile</strong></p>
                        <div class="code-block">
                            <pre><code class="language-dockerfile">FROM node:16-alpine

# Створити директорію додатку
WORKDIR /usr/src/app

# Скопіювати package files
COPY package*.json ./

# Встановити залежності
RUN npm ci --only=production

# Створити користувача
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

# Скопіювати код додатку
COPY . .

# Змінити власника
RUN chown -R nodejs:nodejs /usr/src/app
USER nodejs

EXPOSE 3000

CMD ["npm", "start"]</code></pre>
                        </div>

                        <h4>Статичний сайт з Nginx</h4>
                        <p><strong>index.html</strong></p>
                        <div class="code-block">
                            <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Мій Docker сайт&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Привіт з Docker!&lt;/h1&gt;
    &lt;p&gt;Це статичний сайт, розгорнутий за допомогою Docker.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
                        </div>

                        <p><strong>Dockerfile</strong></p>
                        <div class="code-block">
                            <pre><code class="language-dockerfile">FROM nginx:alpine

# Скопіювати HTML файли
COPY . /usr/share/nginx/html

# Відкрити порт
EXPOSE 80

# Nginx запускається автоматично</code></pre>
                        </div>

                        <h4>Java Spring Boot додаток</h4>
                        <p><strong>Dockerfile з мульти-стадійною збіркою:</strong></p>
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Стадія збірки
FROM maven:3.8.4-openjdk-17 AS builder
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn clean package -DskipTests

# Продакшн стадія
FROM openjdk:17-jre-slim
RUN useradd -m appuser
WORKDIR /app
COPY --from=builder /app/target/*.jar app.jar
RUN chown appuser:appuser app.jar
USER appuser
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]</code></pre>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">🎯 Практичне завдання</div>
                            <p>Створіть власний Dockerfile для простого веб-сервера:</p>
                            <ol>
                                <li>Створіть HTML сторінку</li>
                                <li>Напишіть Dockerfile на базі nginx</li>
                                <li>Зберіть образ</li>
                                <li>Запустіть контейнер</li>
                                <li>Перевірте результат у браузері</li>
                            </ol>
                        </div>

                        <h4>Найкращі практики</h4>
                        <ul>
                            <li>Використовуйте мінімальні базові образи (Alpine)</li>
                            <li>Запускайте додатки від непривілейованого користувача</li>
                            <li>Використовуйте .dockerignore</li>
                            <li>Групуйте RUN інструкції для зменшення шарів</li>
                            <li>Очищуйте кеші та тимчасові файли</li>
                            <li>Використовуйте мульти-стадійну збірку</li>
                            <li>Помічайте образи конкретними версіями</li>
                        </ul>
                    </div>
                </div>

                <div id="4">
                    <h2 id="4">4. Підключення портів та папок</h2>
                    
                    <div id="4.1">
                        <h3 id="4.1">4.1 Робота з портами</h3>
                        
                        <p>Контейнери Docker ізольовані від зовнішнього світу. Щоб отримати доступ до сервісів у контейнері, потрібно налаштувати прокидування портів.</p>

                        <h4>Основи портів у Docker</h4>
                        <p>Кожен контейнер має власний мережевий простір з портами від 1 до 65535. За замовчуванням ці порти недоступні ззовні.</p>

                        <div class="info-box">
                            <div class="info-box-title">💡 Аналогія</div>
                            <p>Уявіть контейнер як будинок з власними кімнатами (портами). Щоб гості (зовнішні користувачі) могли потрапити в конкретну кімнату, потрібно прокласти до неї окремий шлях з вулиці.</p>
                        </div>

                        <h4>Прокидування портів (-p)</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Базовий синтаксис
docker run -p HOST_PORT:CONTAINER_PORT image

# Приклади:
# Прокинути порт 80 контейнера на порт 8080 хоста
docker run -p 8080:80 nginx

# Прокинути на всі інтерфейси
docker run -p 0.0.0.0:8080:80 nginx

# Прокинути на конкретний інтерфейс
docker run -p 127.0.0.1:8080:80 nginx

# Кілька портів
docker run -p 8080:80 -p 8443:443 nginx</code></pre>
                        </div>

                        <h4>Практичні приклади</h4>
                        
                        <p><strong>Веб-сервер Apache</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Запустити Apache на порту 8080
docker run -d -p 8080:80 --name my-apache httpd

# Перевірити в браузері: http://localhost:8080</code></pre>
                        </div>

                        <p><strong>База даних MySQL</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Запустити MySQL з прокидуванням стандартного порту
docker run -d -p 3306:3306 \
  -e MYSQL_ROOT_PASSWORD=mypassword \
  --name my-mysql mysql

# Підключитися з хоста
mysql -h localhost -P 3306 -u root -p</code></pre>
                        </div>

                        <p><strong>Node.js додаток</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Запустити на нестандартному порту
docker run -d -p 3000:8000 \
  -e PORT=8000 \
  --name my-node-app node-app</code></pre>
                        </div>

                        <h4>Автоматичне призначення портів</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Docker автоматично призначить вільний порт на хості
docker run -d -P nginx

# Подивитися, який порт призначено
docker ps
# або
docker port container_name</code></pre>
                        </div>

                        <h4>Перевірка портів</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Показати прокинуті порти контейнера
docker port my-nginx

# Показати всі запущені контейнери з портами
docker ps

# Перевірити з'єднання
curl http://localhost:8080

# Перевірити чи порт відкритий (Linux/Mac)
netstat -tuln | grep 8080

# Windows
netstat -an | findstr 8080</code></pre>
                        </div>

                        <h4>Expose vs Publish</h4>
                        <p>Важливо розуміти різницю між <code>EXPOSE</code> та <code>-p</code>:</p>

                        <ul>
                            <li><strong>EXPOSE</strong> у Dockerfile - документує порт, не відкриває його</li>
                            <li><strong>-p</strong> при запуску - реально прокидає порт</li>
                        </ul>

                        <div class="code-block">
                            <pre><code class="language-dockerfile"># У Dockerfile
EXPOSE 80
# Це лише документація, порт НЕ буде доступний ззовні</code></pre>
                        </div>

                        <div class="code-block">
                            <pre><code class="language-bash"># При запуску контейнера
docker run -p 8080:80 nginx
# Тепер порт СПРАВДІ доступний на localhost:8080</code></pre>
                        </div>

                        <div class="info-box warning">
                            <div class="info-box-title">⚠️ Важливо</div>
                            <p>Порт може бути зайнятий іншим процесом. Завжди перевіряйте доступність порту перед запуском контейнера.</p>
                        </div>
                    </div>

                    <div id="4.2">
                        <h3 id="4.2">4.2 Монтування папок</h3>
                        
                        <p>За замовчуванням файли в контейнері зникають після його видалення. Монтування папок дозволяє зберігати дані та обмінюватися файлами між хостом і контейнером.</p>

                        <h4>Типи монтування</h4>
                        <p>Docker підтримує три типи монтування:</p>
                        
                        <ul>
                            <li><strong>Bind mounts</strong> - прив'язка до конкретної папки на хості</li>
                            <li><strong>Named volumes</strong> - керовані Docker томи</li>
                            <li><strong>tmpfs mounts</strong> - тимчасові файли в пам'яті</li>
                        </ul>

                        <h4>Bind Mounts</h4>
                        <p>Найпростіший спосіб - прив'язати папку хоста до папки в контейнері:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Базовий синтаксис
docker run -v HOST_PATH:CONTAINER_PATH image

# Примонтувати поточну директорію
docker run -v $(pwd):/app nginx

# Windows (PowerShell)
docker run -v ${PWD}:/app nginx

# Windows (Command Prompt)  
docker run -v %cd%:/app nginx

# Абсолютний шлях
docker run -v /home/user/data:/data nginx</code></pre>
                        </div>

                        <h4>Практичні приклади Bind Mounts</h4>
                        
                        <p><strong>Розробка веб-сайту</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Примонтувати папку з HTML файлами до Nginx
docker run -d -p 8080:80 \
  -v $(pwd)/html:/usr/share/nginx/html \
  --name dev-server nginx

# Тепер зміни в папці html/ будуть відображатися миттєво</code></pre>
                        </div>

                        <p><strong>База даних з постійними даними</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Створити папку для даних
mkdir mysql-data

# Запустити MySQL з монтуванням даних
docker run -d -p 3306:3306 \
  -v $(pwd)/mysql-data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=mypassword \
  --name persistent-mysql mysql</code></pre>
                        </div>

                        <p><strong>Розробка Python додатку</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Примонтувати код для автоматичного перезавантаження
docker run -d -p 5000:5000 \
  -v $(pwd):/app \
  -w /app \
  --name dev-flask python:3.9 \
  python -c "
import os
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello():
    return 'Hello from mounted volume!'

if __name__ == '__main__':
    app.run(host='0.0.0.0', debug=True)
"</code></pre>
                        </div>

                        <h4>Права доступу</h4>
                        <p>При монтуванні можуть виникнути проблеми з правами доступу:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Монтування тільки для читання
docker run -v $(pwd):/app:ro nginx

# Встановити конкретного користувача
docker run --user $(id -u):$(id -g) -v $(pwd):/app nginx

# Linux: виправити права після створення файлів
sudo chown -R $USER:$USER ./data</code></pre>
                        </div>

                        <h4>Named Volumes</h4>
                        <p>Named volumes - це рекомендований спосіб збереження даних у Docker:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Створити named volume
docker volume create my-data

# Використати named volume
docker run -d -v my-data:/data nginx

# Переглянути всі volumes
docker volume ls

# Детальна інформація про volume
docker volume inspect my-data

# Видалити volume
docker volume rm my-data</code></pre>
                        </div>

                        <h4>Переваги Named Volumes</h4>
                        <ul>
                            <li>Керуються Docker (автоматичне створення папок)</li>
                            <li>Працюють однаково на всіх платформах</li>
                            <li>Можна створювати резервні копії</li>
                            <li>Кращі права доступу</li>
                            <li>Можна використовувати в кількох контейнерах</li>
                        </ul>

                        <div class="info-box">
                            <div class="info-box-title">💡 Коли що використовувати</div>
                            <p><strong>Bind mounts:</strong> розробка, конфігурація, логіни<br/>
                            <strong>Named volumes:</strong> бази даних, постійні дані в продакшні</p>
                        </div>
                    </div>

                    <div id="4.3">
                        <h3 id="4.3">4.3 Збереження даних</h3>
                        
                        <p>Правильне управління даними критично важливе для продакшн застосунків. Розглянемо різні стратегії збереження даних.</p>

                        <h4>Життєвий цикл даних</h4>
                        <p>Дані в Docker можуть зберігатися на різних рівнях:</p>
                        
                        <ul>
                            <li><strong>Шар контейнера</strong> - зникає при видаленні контейнера</li>
                            <li><strong>Named volumes</strong> - зберігаються навіть після видалення контейнера</li>
                            <li><strong>Bind mounts</strong> - зберігаються на хості</li>
                        </ul>

                        <h4>Практичний приклад: WordPress з MySQL</h4>
                        <p>Створимо повноцінний WordPress сайт з постійним збереженням даних:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># 1. Створити volumes для даних
docker volume create wordpress-db
docker volume create wordpress-files

# 2. Запустити MySQL
docker run -d \
  --name wordpress-mysql \
  -e MYSQL_ROOT_PASSWORD=rootpass \
  -e MYSQL_DATABASE=wordpress \
  -e MYSQL_USER=wpuser \
  -e MYSQL_PASSWORD=wppass \
  -v wordpress-db:/var/lib/mysql \
  mysql:8.0

# 3. Запустити WordPress
docker run -d \
  --name wordpress-site \
  -p 8080:80 \
  -e WORDPRESS_DB_HOST=wordpress-mysql:3306 \
  -e WORDPRESS_DB_USER=wpuser \
  -e WORDPRESS_DB_PASSWORD=wppass \
  -e WORDPRESS_DB_NAME=wordpress \
  -v wordpress-files:/var/www/html \
  --link wordpress-mysql \
  wordpress</code></pre>
                        </div>

                        <h4>Резервне копіювання даних</h4>
                        
                        <p><strong>Backup Named Volume</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Створити backup volume'у
docker run --rm \
  -v wordpress-db:/data \
  -v $(pwd):/backup \
  ubuntu tar czf /backup/wordpress-db-backup.tar.gz -C /data .

# Відновити з backup'у
docker run --rm \
  -v wordpress-db:/data \
  -v $(pwd):/backup \
  ubuntu tar xzf /backup/wordpress-db-backup.tar.gz -C /data</code></pre>
                        </div>

                        <p><strong>Backup бази даних MySQL</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Створити SQL dump
docker exec wordpress-mysql mysqldump \
  -u wpuser -pwppass wordpress > wordpress-backup.sql

# Відновити з SQL dump
docker exec -i wordpress-mysql mysql \
  -u wpuser -pwppass wordpress < wordpress-backup.sql</code></pre>
                        </div>

                        <h4>Очищення даних</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Видалити всі невикористовувані volumes
docker volume prune

# Видалити конкретний volume (тільки якщо не використовується)
docker volume rm my-volume

# Примусово видалити volume (видалити контейнери спочатку)
docker rm -f $(docker ps -aq)
docker volume rm my-volume</code></pre>
                        </div>

                        <h4>Моніторинг використання дискового простору</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Показати використання простору Docker
docker system df

# Детальна інформація
docker system df -v

# Розмір конкретного volume
docker system df -v | grep volume-name</code></pre>
                        </div>

                        <h4>Стратегії для продакшну</h4>
                        
                        <p><strong>1. Використання зовнішніх баз даних</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Підключення до зовнішньої бази
docker run -d \
  -e DATABASE_URL=postgresql://user:pass@external-db:5432/myapp \
  my-app</code></pre>
                        </div>

                        <p><strong>2. Мережеві сховища</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Монтування NFS
docker run -d \
  --mount type=volume,source=nfs-volume,target=/data,volume-driver=nfs \
  my-app</code></pre>
                        </div>

                        <p><strong>3. Хмарні сховища</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Використання AWS S3 для файлів
docker run -d \
  -e AWS_ACCESS_KEY_ID=your_key \
  -e AWS_SECRET_ACCESS_KEY=your_secret \
  -e S3_BUCKET=my-app-files \
  my-app</code></pre>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">🎯 Практичне завдання</div>
                            <p>Створіть простий блог з збереженням даних:</p>
                            <ol>
                                <li>Запустіть MySQL з named volume</li>
                                <li>Запустіть WordPress з монтуванням файлів</li>
                                <li>Створіть пост у WordPress</li>
                                <li>Видаліть контейнери</li>
                                <li>Запустіть знову - дані повинні зберегтися</li>
                            </ol>
                        </div>

                        <h4>Найкращі практики</h4>
                        <ul>
                            <li>Завжди використовуйте volumes для важливих даних</li>
                            <li>Регулярно створюйте резервні копії</li>
                            <li>Тестуйте процедури відновлення</li>
                            <li>Використовуйте readonly монтування де можливо</li>
                            <li>Моніторьте використання дискового простору</li>
                            <li>Документуйте структуру даних</li>
                        </ul>
                    </div>
                </div>

                <div id="5">
                    <h2 id="5">5. Docker Compose</h2>
                    
                    <div id="5.1">
                        <h3 id="5.1">5.1 Що таке Docker Compose</h3>
                        
                        <p>Docker Compose - це інструмент для визначення та запуску багатоконтейнерних Docker застосунків. Замість запуску кожного контейнера окремо, ви описуєте всю архітектуру в одному файлі.</p>

                        <h4>Навіщо потрібен Docker Compose?</h4>
                        <p>Уявіть типовий веб-застосунок:</p>
                        <ul>
                            <li>Веб-сервер (Nginx)</li>
                            <li>Застосунок (Node.js/Python/PHP)</li>
                            <li>База даних (MySQL/PostgreSQL)</li>
                            <li>Кеш (Redis)</li>
                        </ul>

                        <p>Без Compose потрібно було б запускати 4 окремі команди:</p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Без Docker Compose - багато команд
docker run -d --name db -e MYSQL_ROOT_PASSWORD=pass mysql
docker run -d --name redis redis
docker run -d --name app --link db --link redis my-app
docker run -d --name web --link app -p 80:80 nginx</code></pre>
                        </div>

                        <p>З Docker Compose - одна команда:</p>
                        <div class="code-block">
                            <pre><code class="language-bash"># З Docker Compose - одна команда
docker-compose up -d</code></pre>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">💡 Аналогія</div>
                            <p>Docker Compose як диригент оркестру - він координує всі контейнери (музиканти), щоб вони грали разом в гармонії.</p>
                        </div>

                        <h4>Переваги Docker Compose</h4>
                        <ul>
                            <li><strong>Простота</strong> - один файл для всього стеку</li>
                            <li><strong>Відтворюваність</strong> - однакове середовище скрізь</li>
                            <li><strong>Мережі</strong> - автоматичне створення мереж</li>
                            <li><strong>Volumes</strong> - централізоване управління даними</li>
                            <li><strong>Змінні</strong> - гнучка конфігурація</li>
                            <li><strong>Масштабування</strong> - легко збільшити кількість копій</li>
                        </ul>

                        <h4>Встановлення Docker Compose</h4>
                        <p>На більшості систем Docker Compose входить до Docker Desktop. Перевірити можна так:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Перевірити версію
docker-compose --version

# Нова версія (вбудована в Docker)
docker compose version</code></pre>
                        </div>

                        <p>Якщо Compose не встановлено (Linux):</p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Встановити Docker Compose на Linux
sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose</code></pre>
                        </div>

                        <h4>Основні поняття</h4>
                        <ul>
                            <li><strong>Service</strong> - опис контейнера (образ, порти, volumes)</li>
                            <li><strong>Network</strong> - мережа для зв'язку між сервісами</li>
                            <li><strong>Volume</strong> - постійне сховище даних</li>
                            <li><strong>Environment</strong> - змінні оточення</li>
                            <li><strong>Dependencies</strong> - залежності між сервісами</li>
                        </ul>
                    </div>

                    <div id="5.2">
                        <h3 id="5.2">5.2 Перший docker-compose.yml</h3>
                        
                        <p>Файл <code>docker-compose.yml</code> використовує формат YAML для опису сервісів. Створимо простий приклад.</p>

                        <h4>Структура файлу</h4>
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'  # Версія формату Compose

services:       # Список сервісів
  service-name:
    # Конфігурація сервісу

volumes:        # Named volumes (необов'язково)
  volume-name:

networks:       # Custom networks (необов'язково)
  network-name:</code></pre>
                        </div>

                        <h4>Простий приклад: веб-сервер</h4>
                        <p>Створимо файл <code>docker-compose.yml</code>:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  web:
    image: nginx
    ports:
      - "8080:80"
    volumes:
      - ./html:/usr/share/nginx/html</code></pre>
                        </div>

                        <p>Запустити:</p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Запустити в фоновому режимі
docker-compose up -d

# Переглянути логи
docker-compose logs

# Зупинити та видалити
docker-compose down</code></pre>
                        </div>

                        <h4>Приклад з базою даних</h4>
                        <p>Додамо MySQL до нашого веб-сервера:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  web:
    image: nginx
    ports:
      - "8080:80"
    volumes:
      - ./html:/usr/share/nginx/html
    depends_on:
      - db

  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: mypassword
      MYSQL_DATABASE: myapp
      MYSQL_USER: user
      MYSQL_PASSWORD: userpass
    volumes:
      - db_data:/var/lib/mysql
    ports:
      - "3306:3306"

volumes:
  db_data:</code></pre>
                        </div>

                        <h4>Основні команди Docker Compose</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Запустити всі сервіси
docker-compose up

# Запустити в фоновому режимі
docker-compose up -d

# Зупинити сервіси
docker-compose stop

# Зупинити та видалити контейнери
docker-compose down

# Зупинити та видалити контейнери + volumes + мережі
docker-compose down -v

# Переглянути статус
docker-compose ps

# Переглянути логи
docker-compose logs

# Переглянути логи конкретного сервісу
docker-compose logs web

# Виконати команду в сервісі
docker-compose exec web bash

# Перебудувати образи
docker-compose build

# Запустити з перебудовою
docker-compose up --build</code></pre>
                        </div>

                        <h4>Змінні оточення</h4>
                        <p>Можна використовувати змінні для гнучкої конфігурації:</p>
                        
                        <p><strong>.env файл:</strong></p>
                        <div class="code-block">
                            <pre><code class="language-plaintext">MYSQL_ROOT_PASSWORD=supersecret
MYSQL_DATABASE=myapp
WEB_PORT=8080</code></pre>
                        </div>

                        <p><strong>docker-compose.yml:</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  web:
    image: nginx
    ports:
      - "${WEB_PORT}:80"
    
  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}</code></pre>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">💡 Порада</div>
                            <p>Використовуйте <code>.env</code> файли для локальної розробки та змінні оточення для продакшну.</p>
                        </div>

                        <h4>Networks та зв'язок між сервісами</h4>
                        <p>Docker Compose автоматично створює мережу для ваших сервісів:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  app:
    image: my-python-app
    environment:
      # Звертатися до бази за ім'ям сервісу
      DATABASE_HOST: db
      REDIS_HOST: redis
  
  db:
    image: postgres:13
    environment:
      POSTGRES_DB: myapp
  
  redis:
    image: redis:alpine</code></pre>
                        </div>

                        <p>Сервіси можуть звертатися один до одного за їх іменами (app → db, app → redis).</p>
                    </div>

                    <div id="5.3">
                        <h3 id="5.3">5.3 Практичні приклади</h3>
                        
                        <p>Розглянемо реальні приклади використання Docker Compose для популярних стеків.</p>

                        <h4>LAMP Stack (Linux, Apache, MySQL, PHP)</h4>
                        <p>Класичний веб-стек для PHP розробки:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  web:
    image: php:8.1-apache
    ports:
      - "8080:80"
    volumes:
      - ./src:/var/www/html
    depends_on:
      - db

  db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: rootpass
      MYSQL_DATABASE: lampdb
      MYSQL_USER: lampuser
      MYSQL_PASSWORD: lamppass
    volumes:
      - mysql_data:/var/lib/mysql

  phpmyadmin:
    image: phpmyadmin
    ports:
      - "8081:80"
    environment:
      PMA_HOST: db
      PMA_USER: root
      PMA_PASSWORD: rootpass
    depends_on:
      - db

volumes:
  mysql_data:</code></pre>
                        </div>

                        <h4>Node.js + MongoDB Stack</h4>
                        <p>Сучасний стек для JavaScript розробки:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  app:
    build: .  # Використовуємо локальний Dockerfile
    ports:
      - "3000:3000"
    environment:
      NODE_ENV: development
      MONGODB_URI: mongodb://mongo:27017/myapp
      REDIS_URL: redis://redis:6379
    volumes:
      - .:/usr/src/app
      - /usr/src/app/node_modules
    depends_on:
      - mongo
      - redis

  mongo:
    image: mongo:5
    volumes:
      - mongo_data:/data/db
    ports:
      - "27017:27017"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  mongo_data:</code></pre>
                        </div>

                        <h4>WordPress + MySQL</h4>
                        <p>Популярна CMS з базою даних:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  wordpress:
    image: wordpress:latest
    ports:
      - "8080:80"
    environment:
      WORDPRESS_DB_HOST: db:3306
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
      WORDPRESS_DB_NAME: wordpress
    volumes:
      - wordpress_data:/var/www/html
    depends_on:
      - db

  db:
    image: mysql:8.0
    environment:
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress
      MYSQL_ROOT_PASSWORD: rootpassword
    volumes:
      - db_data:/var/lib/mysql

volumes:
  wordpress_data:
  db_data:</code></pre>
                        </div>

                        <h4>Development Stack з Hot Reload</h4>
                        <p>Налаштування для розробки з автоматичним перезавантаженням:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  frontend:
    image: node:16
    working_dir: /app
    volumes:
      - ./frontend:/app
    command: npm run dev
    ports:
      - "3000:3000"
    environment:
      - CHOKIDAR_USEPOLLING=true  # Для Windows

  backend:
    image: python:3.9
    working_dir: /app
    volumes:
      - ./backend:/app
    command: python manage.py runserver 0.0.0.0:8000
    ports:
      - "8000:8000"
    environment:
      DATABASE_URL: postgresql://user:pass@db:5432/devdb
    depends_on:
      - db

  db:
    image: postgres:13
    environment:
      POSTGRES_DB: devdb
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:</code></pre>
                        </div>

                        <h4>Масштабування сервісів</h4>
                        <p>Docker Compose дозволяє легко збільшувати кількість копій сервісу:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Запустити 3 копії веб-сервера
docker-compose up -d --scale web=3

# Переглянути запущені контейнери
docker-compose ps</code></pre>
                        </div>

                        <p>Для масштабування потрібен load balancer:</p>
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  nginx:
    image: nginx
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - web

  web:
    image: my-app
    expose:
      - "8000"</code></pre>
                        </div>

                        <h4>Профілі для різних середовищ</h4>
                        <p>Можна створювати різні конфігурації для dev/prod:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  app:
    image: my-app
    
  db:
    image: postgres:13
    
  # Тільки для розробки
  pgadmin:
    image: dpage/pgadmin4
    profiles:
      - dev
    ports:
      - "5050:80"
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@admin.com
      PGADMIN_DEFAULT_PASSWORD: admin</code></pre>
                        </div>

                        <div class="code-block">
                            <pre><code class="language-bash"># Запустити тільки основні сервіси
docker-compose up

# Запустити з dev профілем
docker-compose --profile dev up</code></pre>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">🎯 Практичне завдання</div>
                            <p>Створіть повний стек для блогу:</p>
                            <ol>
                                <li>Створіть docker-compose.yml з WordPress та MySQL</li>
                                <li>Додайте phpMyAdmin для управління базою</li>
                                <li>Налаштуйте volumes для збереження даних</li>
                                <li>Запустіть стек та створіть кілька постів</li>
                                <li>Перезапустіть - переконайтеся, що дані збереглися</li>
                            </ol>
                        </div>

                        <h4>Найкращі практики</h4>
                        <ul>
                            <li>Використовуйте конкретні версії образів замість <code>latest</code></li>
                            <li>Виносьте секрети в змінні оточення</li>
                            <li>Використовуйте <code>.dockerignore</code> при build</li>
                            <li>Групуйте пов'язані сервіси в окремі файли</li>
                            <li>Документуйте налаштування в README</li>
                            <li>Використовуйте health checks для критичних сервісів</li>
                            <li>Налаштуйте restart policies для продакшну</li>
                        </ul>
                    </div>
                </div>

                <div id="6">
                    <h2 id="6">6. Мережі в Docker</h2>
                    
                    <div id="6.1">
                        <h3 id="6.1">6.1 Основи мереж</h3>
                        
                        <p>Мережі в Docker дозволяють контейнерам спілкуватися між собою та з зовнішнім світом. Розуміння мереж критично важливе для побудови багатоконтейнерних застосунків.</p>

                        <h4>Як працюють мережі Docker</h4>
                        <p>Кожен контейнер Docker має власний мережевий простір з:</p>
                        <ul>
                            <li>Власною IP адресою</li>
                            <li>Власними мережевими інтерфейсами</li>
                            <li>Власною таблицею маршрутизації</li>
                            <li>Власними портами</li>
                        </ul>

                        <div class="info-box">
                            <div class="info-box-title">💡 Аналогія</div>
                            <p>Уявіть Docker мережу як район з будинками (контейнерами). Кожен будинок має свою адресу, але всі можуть спілкуватися через спільну інфраструктуру району.</p>
                        </div>

                        <h4>Типи мереж Docker</h4>
                        <p>Docker надає кілька вбудованих типів мереж:</p>

                        <p><strong>1. Bridge (мостова) - за замовчуванням</strong></p>
                        <ul>
                            <li>Ізольована мережа на хості</li>
                            <li>Контейнери можуть спілкуватися між собою</li>
                            <li>Потрібне прокидування портів для доступу ззовні</li>
                        </ul>

                        <p><strong>2. Host (хостова)</strong></p>
                        <ul>
                            <li>Контейнер використовує мережу хоста напряму</li>
                            <li>Найкраща продуктивність</li>
                            <li>Менше ізоляції</li>
                        </ul>

                        <p><strong>3. None (без мережі)</strong></p>
                        <ul>
                            <li>Контейнер повністю ізольований</li>
                            <li>Немає мережевого доступу</li>
                            <li>Використовується для безпеки</li>
                        </ul>

                        <h4>Перегляд мереж</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Показати всі мережі
docker network ls

# Детальна інформація про мережу
docker network inspect bridge

# Показати мережі конкретного контейнера
docker inspect container_name | grep NetworkMode</code></pre>
                        </div>

                        <h4>Мережа за замовчуванням</h4>
                        <p>Коли ви запускаєте контейнер без вказання мережі, він підключається до мережі <code>bridge</code>:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Запустити два контейнери в мережі за замовчуванням
docker run -d --name web1 nginx
docker run -d --name web2 nginx

# Перевірити їх IP адреси
docker inspect web1 | grep IPAddress
docker inspect web2 | grep IPAddress</code></pre>
                        </div>

                        <h4>Тестування з'єднання</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Зайти в контейнер та перевірити мережу
docker exec -it web1 bash

# Всередині контейнера:
ping web2  # Не працюватиме за IP
ping 172.17.0.3  # Працюватиме за IP адресою

# Переглянути мережеві інтерфейси
ip addr show</code></pre>
                        </div>

                        <div class="info-box warning">
                            <div class="info-box-title">⚠️ Обмеження bridge мережі</div>
                            <p>У мережі bridge за замовчуванням контейнери не можуть звертатися один до одного за іменами, тільки за IP адресами.</p>
                        </div>

                        <h4>Host мережа</h4>
                        <p>Контейнер використовує мережу хоста напряму:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Запустити контейнер в host мережі
docker run -d --network host --name host-nginx nginx

# Nginx буде доступний напряму на порту 80 хоста
curl http://localhost:80</code></pre>
                        </div>

                        <h4>None мережа</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Запустити контейнер без мережі
docker run -it --network none --name isolated alpine sh

# Всередині контейнера тільки loopback інтерфейс
ip addr show</code></pre>
                        </div>
                    </div>

                    <div id="6.2">
                        <h3 id="6.2">6.2 З'єднання контейнерів</h3>
                        
                        <p>Існує кілька способів з'єднати контейнери для спілкування між собою. Розглянемо сучасні підходи.</p>

                        <h4>Legacy: --link (застарілий)</h4>
                        <p>Раніше використовувався параметр <code>--link</code>, але зараз він застарілий:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Застарілий спосіб (не рекомендується)
docker run -d --name db mysql
docker run -d --name app --link db my-app</code></pre>
                        </div>

                        <div class="info-box warning">
                            <div class="info-box-title">⚠️ Не використовуйте --link</div>
                            <p>Параметр <code>--link</code> застарілий і може бути видалений у майбутніх версіях Docker. Використовуйте custom networks.</p>
                        </div>

                        <h4>Сучасний підхід: Custom Networks</h4>
                        <p>Створення власних мереж - правильний спосіб з'єднання контейнерів:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Створити custom network
docker network create my-network

# Запустити контейнери в цій мережі
docker run -d --name db --network my-network mysql
docker run -d --name app --network my-network my-app

# Тепер app може звертатися до db за іменем:
# mysql -h db -u user -p</code></pre>
                        </div>

                        <h4>Практичний приклад: WordPress + MySQL</h4>
                        <p>Створимо мережу для WordPress сайту:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># 1. Створити мережу
docker network create wordpress-net

# 2. Запустити MySQL
docker run -d \
  --name wp-mysql \
  --network wordpress-net \
  -e MYSQL_ROOT_PASSWORD=rootpass \
  -e MYSQL_DATABASE=wordpress \
  -e MYSQL_USER=wpuser \
  -e MYSQL_PASSWORD=wppass \
  mysql:8.0

# 3. Запустити WordPress
docker run -d \
  --name wp-site \
  --network wordpress-net \
  -p 8080:80 \
  -e WORDPRESS_DB_HOST=wp-mysql:3306 \
  -e WORDPRESS_DB_USER=wpuser \
  -e WORDPRESS_DB_PASSWORD=wppass \
  -e WORDPRESS_DB_NAME=wordpress \
  wordpress</code></pre>
                        </div>

                        <h4>Підключення до кількох мереж</h4>
                        <p>Контейнер може бути підключений до кількох мереж одночасно:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Створити дві мережі
docker network create frontend-net
docker network create backend-net

# Запустити контейнер в одній мережі
docker run -d --name app --network frontend-net my-app

# Підключити до другої мережі
docker network connect backend-net app

# Тепер app підключений до обох мереж</code></pre>
                        </div>

                        <h4>Відключення від мережі</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Відключити контейнер від мережі
docker network disconnect frontend-net app

# Перевірити підключення
docker inspect app | grep NetworkMode</code></pre>
                        </div>

                        <h4>Тестування з'єднання</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Тестувати DNS резолюцію між контейнерами
docker exec wp-site ping wp-mysql

# Тестувати підключення до порту
docker exec wp-site nc -zv wp-mysql 3306

# Переглянути мережеву конфігурацію
docker exec wp-site cat /etc/hosts
docker exec wp-site nslookup wp-mysql</code></pre>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">💡 Переваги custom networks</div>
                            <ul>
                                <li>DNS резолюція за іменами контейнерів</li>
                                <li>Кращий контроль мережевого трафіку</li>
                                <li>Можливість підключення/відключення на льоту</li>
                                <li>Ізоляція різних застосунків</li>
                            </ul>
                        </div>
                    </div>

                    <div id="6.3">
                        <h3 id="6.3">6.3 Створення власних мереж</h3>
                        
                        <p>Створення власних мереж дає повний контроль над мережевою топологією ваших застосунків.</p>

                        <h4>Типи custom мереж</h4>
                        
                        <p><strong>Bridge networks</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Створити bridge мережу
docker network create my-bridge

# З додатковими параметрами
docker network create \
  --driver bridge \
  --subnet=192.168.1.0/24 \
  --ip-range=192.168.1.128/25 \
  --gateway=192.168.1.1 \
  custom-bridge</code></pre>
                        </div>

                        <p><strong>Overlay networks (для Swarm)</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash"># Overlay мережа для кластеру
docker network create \
  --driver overlay \
  --attachable \
  swarm-network</code></pre>
                        </div>

                        <h4>Налаштування підмереж</h4>
                        <p>Можна створювати мережі з конкретними IP діапазонами:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Мережа з конкретною підмережею
docker network create \
  --subnet=10.0.0.0/16 \
  --gateway=10.0.0.1 \
  production-net

# Запустити контейнер з статичною IP
docker run -d \
  --name web \
  --network production-net \
  --ip 10.0.0.10 \
  nginx</code></pre>
                        </div>

                        <h4>Практичний приклад: Multi-tier архітектура</h4>
                        <p>Створимо мережі для 3-tier застосунку:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># 1. Створити мережі для кожного рівня
docker network create frontend-tier
docker network create backend-tier
docker network create database-tier

# 2. База даних (тільки backend-tier)
docker run -d \
  --name database \
  --network database-tier \
  -e POSTGRES_DB=myapp \
  -e POSTGRES_USER=user \
  -e POSTGRES_PASSWORD=pass \
  postgres:13

# 3. API сервер (backend-tier + database-tier)
docker run -d \
  --name api \
  --network backend-tier \
  -e DATABASE_URL=postgresql://user:pass@database:5432/myapp \
  my-api-server

docker network connect database-tier api

# 4. Веб-сервер (frontend-tier + backend-tier)
docker run -d \
  --name webapp \
  --network frontend-tier \
  -p 80:80 \
  -e API_URL=http://api:8000 \
  my-webapp

docker network connect backend-tier webapp</code></pre>
                        </div>

                        <h4>Мережева ізоляція</h4>
                        <p>Різні мережі ізольовані одна від одної:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Створити дві ізольовані мережі
docker network create app1-network
docker network create app2-network

# Контейнери в різних мережах не можуть спілкуватися
docker run -d --name app1-web --network app1-network nginx
docker run -d --name app2-web --network app2-network nginx

# Це не працюватиме:
docker exec app1-web ping app2-web</code></pre>
                        </div>

                        <h4>Управління мережами</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Переглянути детальну інформацію
docker network inspect my-network

# Побачити які контейнери підключені
docker network ls
docker network inspect bridge --format='{{range .Containers}}{{.Name}} {{end}}'

# Видалити мережу
docker network rm my-network

# Видалити всі невикористовувані мережі
docker network prune</code></pre>
                        </div>

                        <h4>Мережі в Docker Compose</h4>
                        <p>Docker Compose автоматично створює мережі:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  web:
    image: nginx
    networks:
      - frontend
      - backend
  
  api:
    image: my-api
    networks:
      - backend
      - database
  
  db:
    image: postgres
    networks:
      - database

networks:
  frontend:
  backend:
  database:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16</code></pre>
                        </div>

                        <h4>Зовнішні мережі</h4>
                        <p>Підключення до існуючих мереж:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  app:
    image: my-app
    networks:
      - existing-network

networks:
  existing-network:
    external: true</code></pre>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">🎯 Практичне завдання</div>
                            <p>Створіть мікросервісну архітектуру:</p>
                            <ol>
                                <li>Створіть 3 мережі: public, internal, database</li>
                                <li>Запустіть nginx в public мережі</li>
                                <li>Запустіть API сервер в public та internal</li>
                                <li>Запустіть базу даних тільки в database мережі</li>
                                <li>Підключіть API до database мережі</li>
                                <li>Протестуйте з'єднання між сервісами</li>
                            </ol>
                        </div>

                        <h4>Найкращі практики мереж</h4>
                        <ul>
                            <li>Створюйте окремі мережі для різних застосунків</li>
                            <li>Використовуйте мережеву сегментацію для безпеки</li>
                            <li>Надавайте описові імена мережам</li>
                            <li>Документуйте мережеву топологію</li>
                            <li>Використовуйте статичні IP тільки коли необхідно</li>
                            <li>Регулярно очищуйте невикористовувані мережі</li>
                            <li>Тестуйте мережеве з'єднання після змін</li>
                        </ul>
                    </div>
                </div>

                <div id="7">
                    <h2 id="7">7. Практичні проекти</h2>
                    
                    <div id="7.1">
                        <h3 id="7.1">7.1 Веб-додаток з базою даних</h3>
                        
                        <p>Створимо повноцінний веб-додаток з фронтендом, API та базою даних. Це практичний приклад того, як поєднати всі знання з попередніх розділів.</p>

                        <h4>Архітектура проекту</h4>
                        <p>Наш проект складатиметься з:</p>
                        <ul>
                            <li><strong>Frontend</strong> - React.js додаток</li>
                            <li><strong>Backend API</strong> - Node.js Express сервер</li>
                            <li><strong>Database</strong> - PostgreSQL база даних</li>
                            <li><strong>Cache</strong> - Redis для кешування</li>
                        </ul>

                        <h4>Структура файлів</h4>
                        <div class="code-block">
                            <pre><code class="language-plaintext">webapp-project/
├── docker-compose.yml
├── frontend/
│   ├── Dockerfile
│   ├── package.json
│   └── src/
├── backend/
│   ├── Dockerfile
│   ├── package.json
│   └── server.js
└── database/
    └── init.sql</code></pre>
                        </div>

                        <h4>Backend API (Node.js)</h4>
                        <p><strong>backend/package.json</strong></p>
                        <div class="code-block">
                            <pre><code class="language-json">{
  "name": "webapp-backend",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.0",
    "pg": "^8.8.0",
    "redis": "^4.3.0",
    "cors": "^2.8.5"
  }
}</code></pre>
                        </div>

                        <p><strong>backend/server.js</strong></p>
                        <div class="code-block">
                            <pre><code class="language-javascript">const express = require('express');
const { Pool } = require('pg');
const redis = require('redis');
const cors = require('cors');

const app = express();
const port = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());

// Database connection
const pool = new Pool({
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 5432,
  database: process.env.DB_NAME || 'webapp',
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD || 'password'
});

// Redis connection
const redisClient = redis.createClient({
  host: process.env.REDIS_HOST || 'localhost',
  port: process.env.REDIS_PORT || 6379
});

// Routes
app.get('/api/users', async (req, res) => {
  try {
    // Check cache first
    const cacheKey = 'users:all';
    const cached = await redisClient.get(cacheKey);
    
    if (cached) {
      return res.json(JSON.parse(cached));
    }

    // Query database
    const result = await pool.query('SELECT * FROM users');
    
    // Cache result for 5 minutes
    await redisClient.setEx(cacheKey, 300, JSON.stringify(result.rows));
    
    res.json(result.rows);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
});

app.post('/api/users', async (req, res) => {
  try {
    const { name, email } = req.body;
    const result = await pool.query(
      'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING *',
      [name, email]
    );
    
    // Clear cache
    await redisClient.del('users:all');
    
    res.status(201).json(result.rows[0]);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
});

app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});</code></pre>
                        </div>

                        <p><strong>backend/Dockerfile</strong></p>
                        <div class="code-block">
                            <pre><code class="language-dockerfile">FROM node:16-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

# Copy app source
COPY . .

# Change ownership
RUN chown -R nodejs:nodejs /app
USER nodejs

EXPOSE 3000

CMD ["npm", "start"]</code></pre>
                        </div>

                        <h4>Database initialization</h4>
                        <p><strong>database/init.sql</strong></p>
                        <div class="code-block">
                            <pre><code class="language-sql">CREATE TABLE IF NOT EXISTS users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  email VARCHAR(100) UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Sample data
INSERT INTO users (name, email) VALUES 
  ('Олександр Петров', 'alex@example.com'),
  ('Марія Іванова', 'maria@example.com'),
  ('Дмитро Коваленко', 'dmitro@example.com');</code></pre>
                        </div>

                        <h4>Frontend (React)</h4>
                        <p><strong>frontend/package.json</strong></p>
                        <div class="code-block">
                            <pre><code class="language-json">{
  "name": "webapp-frontend",
  "version": "1.0.0",
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "axios": "^0.27.2"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build"
  },
  "browserslist": {
    "production": [">0.2%", "not dead"],
    "development": ["last 1 chrome version"]
  }
}</code></pre>
                        </div>

                        <p><strong>frontend/Dockerfile</strong></p>
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Multi-stage build
FROM node:16-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production stage
FROM nginx:alpine
COPY --from=builder /app/build /usr/share/nginx/html

# Custom nginx config
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]</code></pre>
                        </div>

                        <h4>Docker Compose конфігурація</h4>
                        <p><strong>docker-compose.yml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  # Frontend
  frontend:
    build: ./frontend
    ports:
      - "3000:80"
    depends_on:
      - backend
    networks:
      - frontend-net

  # Backend API
  backend:
    build: ./backend
    ports:
      - "3001:3000"
    environment:
      DB_HOST: database
      DB_NAME: webapp
      DB_USER: postgres
      DB_PASSWORD: password
      REDIS_HOST: cache
    depends_on:
      - database
      - cache
    networks:
      - frontend-net
      - backend-net

  # Database
  database:
    image: postgres:13
    environment:
      POSTGRES_DB: webapp
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - backend-net

  # Cache
  cache:
    image: redis:7-alpine
    networks:
      - backend-net

volumes:
  postgres_data:

networks:
  frontend-net:
  backend-net:</code></pre>
                        </div>

                        <h4>Запуск проекту</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># 1. Створити структуру папок
mkdir -p webapp-project/{frontend,backend,database}
cd webapp-project

# 2. Створити всі файли (показані вище)

# 3. Запустити весь стек
docker-compose up --build

# 4. Перевірити, що все працює
curl http://localhost:3001/api/users</code></pre>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">🎯 Результат</div>
                            <p>Після запуску у вас буде:</p>
                            <ul>
                                <li>Frontend на http://localhost:3000</li>
                                <li>API на http://localhost:3001</li>
                                <li>PostgreSQL з даними</li>
                                <li>Redis кеш</li>
                            </ul>
                        </div>
                    </div>

                    <div id="7.2">
                        <h3 id="7.2">7.2 WordPress сайт</h3>
                        
                        <p>Створимо повноцінний WordPress сайт з базою даних, SSL сертифікатами та системою резервного копіювання.</p>

                        <h4>Розширена WordPress конфігурація</h4>
                        <p><strong>docker-compose.yml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  # Nginx reverse proxy
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
      - wordpress_files:/var/www/html
    depends_on:
      - wordpress
    networks:
      - frontend

  # WordPress
  wordpress:
    image: wordpress:php8.1-fpm
    environment:
      WORDPRESS_DB_HOST: mysql:3306
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: ${WORDPRESS_DB_PASSWORD}
      WORDPRESS_DB_NAME: wordpress
      WORDPRESS_CONFIG_EXTRA: |
        define('WP_REDIS_HOST', 'redis');
        define('WP_REDIS_PORT', 6379);
        define('WP_CACHE', true);
    volumes:
      - wordpress_files:/var/www/html
      - ./wordpress/uploads.ini:/usr/local/etc/php/conf.d/uploads.ini
    depends_on:
      - mysql
      - redis
    networks:
      - frontend
      - backend

  # MySQL Database
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: ${WORDPRESS_DB_PASSWORD}
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql
      - ./mysql/my.cnf:/etc/mysql/conf.d/my.cnf
    networks:
      - backend
    command: --default-authentication-plugin=mysql_native_password

  # Redis Cache
  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
    networks:
      - backend

  # phpMyAdmin
  phpmyadmin:
    image: phpmyadmin/phpmyadmin
    environment:
      PMA_HOST: mysql
      PMA_USER: root
      PMA_PASSWORD: ${MYSQL_ROOT_PASSWORD}
    ports:
      - "8080:80"
    depends_on:
      - mysql
    networks:
      - backend

  # Backup service
  backup:
    image: alpine
    volumes:
      - mysql_data:/mysql_data:ro
      - wordpress_files:/wordpress_files:ro
      - ./backups:/backups
    command: |
      sh -c "
        apk add --no-cache mysql-client gzip &&
        while true; do
          echo 'Creating backup...' &&
          mysqldump -h mysql -u root -p${MYSQL_ROOT_PASSWORD} wordpress | gzip > /backups/wordpress_$$(date +%Y%m%d_%H%M%S).sql.gz &&
          tar -czf /backups/wordpress_files_$$(date +%Y%m%d_%H%M%S).tar.gz -C /wordpress_files . &&
          find /backups -name '*.gz' -mtime +7 -delete &&
          echo 'Backup completed' &&
          sleep 86400
        done
      "
    depends_on:
      - mysql
    networks:
      - backend

volumes:
  wordpress_files:
  mysql_data:
  redis_data:

networks:
  frontend:
  backend:</code></pre>
                        </div>

                        <h4>Nginx конфігурація</h4>
                        <p><strong>nginx/nginx.conf</strong></p>
                        <div class="code-block">
                            <pre><code class="language-nginx">events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # Logging
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=login:10m rate=1r/s;

    # Upstream for WordPress
    upstream wordpress {
        server wordpress:9000;
    }

    # HTTP redirect to HTTPS
    server {
        listen 80;
        server_name localhost;
        return 301 https://$server_name$request_uri;
    }

    # HTTPS server
    server {
        listen 443 ssl http2;
        server_name localhost;
        root /var/www/html;
        index index.php index.html;

        # SSL configuration
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;

        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header X-Content-Type-Options "nosniff" always;

        # WordPress specific
        location / {
            try_files $uri $uri/ /index.php?$args;
        }

        location ~ \.php$ {
            fastcgi_split_path_info ^(.+\.php)(/.+)$;
            fastcgi_pass wordpress;
            fastcgi_index index.php;
            include fastcgi_params;
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
            fastcgi_param PATH_INFO $fastcgi_path_info;
        }

        # Cache static files
        location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }

        # Security
        location ~ /\.well-known {
            allow all;
        }

        location ~ /\. {
            deny all;
        }

        # Rate limit wp-login
        location = /wp-login.php {
            limit_req zone=login burst=2 nodelay;
            fastcgi_pass wordpress;
            include fastcgi_params;
        }
    }
}</code></pre>
                        </div>

                        <h4>Environment файл</h4>
                        <p><strong>.env</strong></p>
                        <div class="code-block">
                            <pre><code class="language-plaintext">WORDPRESS_DB_PASSWORD=wp_secure_password_123
MYSQL_ROOT_PASSWORD=root_secure_password_456</code></pre>
                        </div>

                        <h4>MySQL оптимізація</h4>
                        <p><strong>mysql/my.cnf</strong></p>
                        <div class="code-block">
                            <pre><code class="language-ini">[mysqld]
# Performance tuning
innodb_buffer_pool_size = 256M
innodb_log_file_size = 64M
max_connections = 100
query_cache_size = 32M

# Character set
character-set-server = utf8mb4
collation-server = utf8mb4_unicode_ci

# Logging
slow_query_log = 1
slow_query_log_file = /var/log/mysql/slow.log
long_query_time = 2</code></pre>
                        </div>

                        <h4>PHP налаштування</h4>
                        <p><strong>wordpress/uploads.ini</strong></p>
                        <div class="code-block">
                            <pre><code class="language-ini">file_uploads = On
memory_limit = 256M
upload_max_filesize = 64M
post_max_size = 64M
max_execution_time = 300</code></pre>
                        </div>

                        <h4>SSL сертифікати (для розробки)</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Створити самопідписний сертифікат
mkdir -p nginx/ssl
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout nginx/ssl/key.pem \
  -out nginx/ssl/cert.pem \
  -subj "/C=UA/ST=Kyiv/L=Kyiv/O=Test/CN=localhost"</code></pre>
                        </div>

                        <h4>Управління сайтом</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Запустити сайт
docker-compose up -d

# Подивитися логи
docker-compose logs -f wordpress

# Створити резервну копію вручну
docker-compose exec backup sh -c "
  mysqldump -h mysql -u root -p\$MYSQL_ROOT_PASSWORD wordpress | gzip > /backups/manual_backup.sql.gz
"

# Відновити з резервної копії
docker-compose exec mysql sh -c "
  zcat /backups/wordpress_20231201_120000.sql.gz | mysql -u root -p\$MYSQL_ROOT_PASSWORD wordpress
"

# Оновити WordPress
docker-compose pull wordpress
docker-compose up -d wordpress</code></pre>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">🎯 Функції сайту</div>
                            <ul>
                                <li>HTTPS з SSL сертифікатами</li>
                                <li>Redis кешування</li>
                                <li>Автоматичні резервні копії</li>
                                <li>phpMyAdmin для управління БД</li>
                                <li>Nginx reverse proxy</li>
                                <li>Оптимізація продуктивності</li>
                            </ul>
                        </div>
                    </div>

                    <div id="7.3">
                        <h3 id="7.3">7.3 API з Redis</h3>
                        
                        <p>Створимо високопродуктивний API з Redis кешуванням, rate limiting та моніторингом.</p>

                        <h4>Python FastAPI з Redis</h4>
                        <p><strong>Структура проекту:</strong></p>
                        <div class="code-block">
                            <pre><code class="language-plaintext">api-project/
├── docker-compose.yml
├── api/
│   ├── Dockerfile
│   ├── requirements.txt
│   ├── main.py
│   └── models.py
├── monitoring/
│   ├── prometheus.yml
│   └── grafana/
└── redis/
    └── redis.conf</code></pre>
                        </div>

                        <p><strong>api/requirements.txt</strong></p>
                        <div class="code-block">
                            <pre><code class="language-plaintext">fastapi==0.68.0
uvicorn==0.15.0
redis==4.3.4
sqlalchemy==1.4.23
psycopg2-binary==2.9.1
pydantic==1.8.2
python-jose==3.3.0
passlib==1.7.4
prometheus-client==0.11.0</code></pre>
                        </div>

                        <p><strong>api/main.py</strong></p>
                        <div class="code-block">
                            <pre><code class="language-python">from fastapi import FastAPI, HTTPException, Depends, status
from fastapi.middleware.cors import CORSMiddleware
import redis
import json
import time
from datetime import datetime, timedelta
from prometheus_client import Counter, Histogram, generate_latest
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="High Performance API", version="1.0.0")

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Redis connection
redis_client = redis.Redis(
    host='redis',
    port=6379,
    decode_responses=True
)

# Prometheus metrics
REQUEST_COUNT = Counter('requests_total', 'Total requests', ['method', 'endpoint'])
REQUEST_LATENCY = Histogram('request_duration_seconds', 'Request latency')

# Rate limiting decorator
def rate_limit(max_requests: int = 100, window: int = 60):
    def decorator(func):
        async def wrapper(*args, **kwargs):
            client_ip = "127.0.0.1"  # In production, get from request
            key = f"rate_limit:{client_ip}"
            
            current = redis_client.get(key)
            if current is None:
                redis_client.setex(key, window, 1)
            else:
                if int(current) >= max_requests:
                    raise HTTPException(
                        status_code=429,
                        detail="Rate limit exceeded"
                    )
                redis_client.incr(key)
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator

# Cache decorator
def cache_result(ttl: int = 300):
    def decorator(func):
        async def wrapper(*args, **kwargs):
            # Create cache key from function name and args
            cache_key = f"cache:{func.__name__}:{hash(str(args) + str(kwargs))}"
            
            # Try to get from cache
            cached = redis_client.get(cache_key)
            if cached:
                logger.info(f"Cache hit for {cache_key}")
                return json.loads(cached)
            
            # Execute function and cache result
            result = await func(*args, **kwargs)
            redis_client.setex(cache_key, ttl, json.dumps(result))
            logger.info(f"Cache miss for {cache_key}, result cached")
            
            return result
        return wrapper
    return decorator

@app.middleware("http")
async def add_process_time_header(request, call_next):
    start_time = time.time()
    
    # Record request
    REQUEST_COUNT.labels(
        method=request.method, 
        endpoint=request.url.path
    ).inc()
    
    response = await call_next(request)
    
    # Record latency
    process_time = time.time() - start_time
    REQUEST_LATENCY.observe(process_time)
    response.headers["X-Process-Time"] = str(process_time)
    
    return response

@app.get("/")
async def root():
    return {"message": "High Performance API with Redis"}

@app.get("/api/users")
@rate_limit(max_requests=50, window=60)
@cache_result(ttl=300)
async def get_users():
    # Simulate database query
    await asyncio.sleep(0.1)
    
    users = [
        {"id": 1, "name": "Олександр", "email": "alex@example.com"},
        {"id": 2, "name": "Марія", "email": "maria@example.com"},
        {"id": 3, "name": "Дмитро", "email": "dmitro@example.com"}
    ]
    
    return {"users": users, "timestamp": datetime.now().isoformat()}

@app.post("/api/users")
@rate_limit(max_requests=10, window=60)
async def create_user(user_data: dict):
    # Invalidate cache
    pattern = "cache:get_users:*"
    for key in redis_client.scan_iter(match=pattern):
        redis_client.delete(key)
    
    # Simulate user creation
    user_id = redis_client.incr("user_counter")
    user = {
        "id": user_id,
        "name": user_data.get("name"),
        "email": user_data.get("email"),
        "created_at": datetime.now().isoformat()
    }
    
    # Store in Redis as example
    redis_client.hset(f"user:{user_id}", mapping=user)
    
    return user

@app.get("/api/analytics")
@cache_result(ttl=60)
async def get_analytics():
    # Get some analytics from Redis
    total_users = redis_client.get("user_counter") or 0
    active_sessions = len(redis_client.keys("session:*"))
    
    # Get rate limit info
    rate_limits = {}
    for key in redis_client.scan_iter(match="rate_limit:*"):
        ip = key.split(":")[-1]
        requests = redis_client.get(key)
        rate_limits[ip] = int(requests)
    
    return {
        "total_users": int(total_users),
        "active_sessions": active_sessions,
        "rate_limits": rate_limits,
        "cache_info": {
            "total_keys": len(redis_client.keys("cache:*")),
            "memory_usage": redis_client.memory_usage("cache:*") if redis_client.keys("cache:*") else 0
        }
    }

@app.get("/health")
async def health_check():
    try:
        # Check Redis connection
        redis_client.ping()
        redis_status = "healthy"
    except:
        redis_status = "unhealthy"
    
    return {
        "status": "healthy" if redis_status == "healthy" else "degraded",
        "redis": redis_status,
        "timestamp": datetime.now().isoformat()
    }

@app.get("/metrics")
async def metrics():
    return generate_latest()</code></pre>
                        </div>

                        <p><strong>api/Dockerfile</strong></p>
                        <div class="code-block">
                            <pre><code class="language-dockerfile">FROM python:3.9-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Create non-root user
RUN useradd -m -u 1000 apiuser

# Copy application code
COPY . .

# Change ownership
RUN chown -R apiuser:apiuser /app
USER apiuser

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]</code></pre>
                        </div>

                        <p><strong>redis/redis.conf</strong></p>
                        <div class="code-block">
                            <pre><code class="language-ini"># Memory management
maxmemory 256mb
maxmemory-policy allkeys-lru

# Persistence
save 900 1
save 300 10
save 60 10000

# Security
requirepass your_redis_password

# Performance
tcp-keepalive 300
timeout 0

# Logging
loglevel notice
logfile /var/log/redis/redis-server.log</code></pre>
                        </div>

                        <p><strong>docker-compose.yml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  # FastAPI application
  api:
    build: ./api
    ports:
      - "8000:8000"
    environment:
      REDIS_URL: redis://redis:6379
    depends_on:
      - redis
    networks:
      - api-network
    deploy:
      replicas: 2
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M

  # Redis cache
  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
      - ./redis/redis.conf:/usr/local/etc/redis/redis.conf
    command: redis-server /usr/local/etc/redis/redis.conf
    networks:
      - api-network
    deploy:
      resources:
        limits:
          memory: 256M

  # Load balancer
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - api
    networks:
      - api-network

  # Monitoring - Prometheus
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
    networks:
      - api-network

  # Monitoring - Grafana
  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    environment:
      GF_SECURITY_ADMIN_PASSWORD: admin
    volumes:
      - grafana_data:/var/lib/grafana
    networks:
      - api-network

  # Redis monitoring
  redis-exporter:
    image: oliver006/redis_exporter
    environment:
      REDIS_ADDR: redis:6379
    networks:
      - api-network

volumes:
  redis_data:
  grafana_data:

networks:
  api-network:</code></pre>
                        </div>

                        <h4>Load testing</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Install Apache Bench
sudo apt-get install apache2-utils

# Test API performance
ab -n 1000 -c 10 http://localhost:8000/api/users

# Test with different endpoints
ab -n 500 -c 5 -p user_data.json -T application/json http://localhost:8000/api/users</code></pre>
                        </div>

                        <h4>Моніторинг</h4>
                        <p>Після запуску доступно:</p>
                        <ul>
                            <li><strong>API</strong>: http://localhost:8000</li>
                            <li><strong>Prometheus</strong>: http://localhost:9090</li>
                            <li><strong>Grafana</strong>: http://localhost:3000 (admin/admin)</li>
                            <li><strong>Metrics</strong>: http://localhost:8000/metrics</li>
                        </ul>

                        <div class="info-box">
                            <div class="info-box-title">🎯 Особливості API</div>
                            <ul>
                                <li>Redis кешування з TTL</li>
                                <li>Rate limiting для захисту</li>
                                <li>Prometheus метрики</li>
                                <li>Health checks</li>
                                <li>Load balancing</li>
                                <li>Horizontal scaling</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div id="8">
                    <h2>8. Розгортання в продакшні</h2>
                    <div id="8.1">
                        <h3 id="8.1">8.1 Підготовка до продакшну</h3>
                        
                        <p>Перехід від розробки до продакшн середовища потребує особливої уваги до безпеки, продуктивності та надійності.</p>

                        <h4>Основні принципи продакшн розгортання</h4>
                        <div class="info-box">
                            <div class="info-box-title">📋 Checklist для продакшну</div>
                            <ul>
                                <li>Використання офіційних базових образів</li>
                                <li>Мінімізація розміру образів</li>
                                <li>Безопасність контейнерів</li>
                                <li>Секрети та конфігурація</li>
                                <li>Моніторинг та логування</li>
                                <li>Backup стратегія</li>
                                <li>Disaster recovery план</li>
                            </ul>
                        </div>

                        <h4>Оптимізація Dockerfile для продакшну</h4>
                        <p>Приклад оптимізованого Dockerfile для Node.js додатку:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Використовуємо офіційний Node.js образ
FROM node:18-alpine AS builder

# Встановлюємо робочу директорію
WORKDIR /app

# Копіюємо package файли та встановлюємо залежності
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# Копіюємо код і збираємо додаток
COPY . .
RUN npm run build

# Продакшн стадія
FROM node:18-alpine AS production

# Створюємо користувача без root прав
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# Встановлюємо робочу директорію
WORKDIR /app

# Копіюємо node_modules та зібраний код
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/package.json ./

# Переключаємось на непривілейованого користувача
USER nodejs

# Відкриваємо порт
EXPOSE 3000

# Налаштовуємо health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js

# Запускаємо додаток
CMD ["node", "dist/index.js"]</code></pre>
                        </div>

                        <h4>Docker Compose для продакшну</h4>
                        <p><strong>docker-compose.prod.yml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  app:
    build: 
      context: .
      target: production
    restart: unless-stopped
    environment:
      NODE_ENV: production
      DATABASE_URL: ${DATABASE_URL}
      REDIS_URL: ${REDIS_URL}
      JWT_SECRET: ${JWT_SECRET}
    ports:
      - "3000:3000"
    depends_on:
      - database
      - redis
    networks:
      - app-network
    deploy:
      replicas: 3
      resources:
        limits:
          memory: 1G
          cpus: '0.5'
        reservations:
          memory: 512M
          cpus: '0.25'

  database:
    image: postgres:15-alpine
    restart: unless-stopped
    environment:
      POSTGRES_DB: ${DB_NAME}
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backups:/backups
    networks:
      - app-network
    deploy:
      resources:
        limits:
          memory: 2G

  redis:
    image: redis:7-alpine
    restart: unless-stopped
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    networks:
      - app-network

  nginx:
    image: nginx:alpine
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
      - nginx_logs:/var/log/nginx
    depends_on:
      - app
    networks:
      - app-network

volumes:
  postgres_data:
  redis_data:
  nginx_logs:

networks:
  app-network:
    driver: bridge</code></pre>
                        </div>

                        <h4>Environment файли</h4>
                        <p><strong>.env.production</strong></p>
                        <div class="code-block">
                            <pre><code class="language-plaintext"># Database
DB_NAME=myapp_prod
DB_USER=myapp_user
DB_PASSWORD=secure_db_password_123
DATABASE_URL=postgresql://myapp_user:secure_db_password_123@database:5432/myapp_prod

# Redis
REDIS_PASSWORD=secure_redis_password_456
REDIS_URL=redis://:secure_redis_password_456@redis:6379

# Application
JWT_SECRET=very_secure_jwt_secret_789
API_KEY=production_api_key_012

# External services
SMTP_HOST=smtp.gmail.com
SMTP_USER=noreply@myapp.com
SMTP_PASS=app_specific_password</code></pre>
                        </div>

                        <h4>Безпека контейнерів</h4>
                        <div class="info-box warning">
                            <div class="info-box-title">⚠️ Важливо для безпеки</div>
                            <ul>
                                <li>Ніколи не запускайте контейнери від root користувача</li>
                                <li>Використовуйте secrets для паролів</li>
                                <li>Обмежуйте ресурси контейнерів</li>
                                <li>Регулярно оновлюйте базові образи</li>
                                <li>Сканируйте образи на вразливості</li>
                            </ul>
                        </div>

                        <h4>Скрипт для розгортання</h4>
                        <p><strong>deploy.sh</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash">#!/bin/bash

set -e

echo "🚀 Starting production deployment..."

# Load environment variables
source .env.production

# Stop old containers
echo "Stopping old containers..."
docker-compose -f docker-compose.prod.yml down

# Pull latest images
echo "Pulling latest images..."
docker-compose -f docker-compose.prod.yml pull

# Build application
echo "Building application..."
docker-compose -f docker-compose.prod.yml build app

# Create backup before deployment
echo "Creating database backup..."
docker-compose -f docker-compose.prod.yml exec -T database pg_dump -U $DB_USER $DB_NAME | gzip > "backups/backup_$(date +%Y%m%d_%H%M%S).sql.gz"

# Start services
echo "Starting services..."
docker-compose -f docker-compose.prod.yml up -d

# Wait for services to be healthy
echo "Waiting for services to be ready..."
sleep 30

# Health check
echo "Performing health check..."
if curl -f http://localhost:3000/health; then
    echo "✅ Deployment successful!"
else
    echo "❌ Health check failed!"
    echo "Rolling back..."
    docker-compose -f docker-compose.prod.yml down
    # Restore from backup if needed
    exit 1
fi

# Clean up old images
echo "Cleaning up old images..."
docker image prune -f

echo "🎉 Deployment completed successfully!"</code></pre>
                        </div>

                        <h4>Моніторинг здоров'я</h4>
                        <p><strong>healthcheck.js</strong></p>
                        <div class="code-block">
                            <pre><code class="language-javascript">const http = require('http');

const options = {
  hostname: 'localhost',
  port: 3000,
  path: '/health',
  method: 'GET',
  timeout: 2000
};

const req = http.request(options, (res) => {
  if (res.statusCode === 200) {
    process.exit(0);
  } else {
    process.exit(1);
  }
});

req.on('error', () => {
  process.exit(1);
});

req.on('timeout', () => {
  req.destroy();
  process.exit(1);
});

req.end();</code></pre>
                        </div>
                    </div>
                    <div id="8.2">
                        <h3 id="8.2">8.2 Хмарні платформи</h3>
                        
                        <p>Розгортання Docker контейнерів у хмарних сервісах надає масштабованість, надійність та керованість.</p>

                        <h4>AWS (Amazon Web Services)</h4>
                        <p>AWS пропонує кілька сервісів для роботи з контейнерами:</p>

                        <div class="info-box">
                            <div class="info-box-title">🔧 AWS Контейнерні сервіси</div>
                            <ul>
                                <li><strong>ECS (Elastic Container Service)</strong> - Керований сервіс оркестрації</li>
                                <li><strong>EKS (Elastic Kubernetes Service)</strong> - Керований Kubernetes</li>
                                <li><strong>Fargate</strong> - Serverless обчислення для контейнерів</li>
                                <li><strong>ECR (Elastic Container Registry)</strong> - Приватний реєстр образів</li>
                            </ul>
                        </div>

                        <h4>Розгортання на AWS ECS</h4>
                        <p><strong>task-definition.json</strong></p>
                        <div class="code-block">
                            <pre><code class="language-json">{
  "family": "myapp-task",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "256",
  "memory": "512",
  "executionRoleArn": "arn:aws:iam::123456789012:role/ecsTaskExecutionRole",
  "containerDefinitions": [
    {
      "name": "myapp",
      "image": "123456789012.dkr.ecr.us-east-1.amazonaws.com/myapp:latest",
      "portMappings": [
        {
          "containerPort": 3000,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "NODE_ENV",
          "value": "production"
        }
      ],
      "secrets": [
        {
          "name": "DATABASE_URL",
          "valueFrom": "arn:aws:secretsmanager:us-east-1:123456789012:secret:myapp/database-url"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/myapp",
          "awslogs-region": "us-east-1",
          "awslogs-stream-prefix": "ecs"
        }
      },
      "healthCheck": {
        "command": ["CMD-SHELL", "curl -f http://localhost:3000/health || exit 1"],
        "interval": 30,
        "timeout": 5,
        "retries": 3
      }
    }
  ]
}</code></pre>
                        </div>

                        <h4>AWS CLI команди</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Build та push образу до ECR
aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 123456789012.dkr.ecr.us-east-1.amazonaws.com

docker build -t myapp .
docker tag myapp:latest 123456789012.dkr.ecr.us-east-1.amazonaws.com/myapp:latest
docker push 123456789012.dkr.ecr.us-east-1.amazonaws.com/myapp:latest

# Реєстрація task definition
aws ecs register-task-definition --cli-input-json file://task-definition.json

# Створення сервісу
aws ecs create-service \
  --cluster myapp-cluster \
  --service-name myapp-service \
  --task-definition myapp-task:1 \
  --desired-count 2 \
  --launch-type FARGATE \
  --network-configuration "awsvpcConfiguration={subnets=[subnet-12345678,subnet-87654321],securityGroups=[sg-12345678],assignPublicIp=ENABLED}"

# Оновлення сервісу
aws ecs update-service \
  --cluster myapp-cluster \
  --service myapp-service \
  --task-definition myapp-task:2</code></pre>
                        </div>

                        <h4>Google Cloud Platform (GCP)</h4>
                        <p>GCP надає Google Kubernetes Engine (GKE) та Cloud Run для контейнерів.</p>

                        <h4>Розгортання на Cloud Run</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Build та push до Google Container Registry
gcloud auth configure-docker
docker build -t gcr.io/PROJECT_ID/myapp:latest .
docker push gcr.io/PROJECT_ID/myapp:latest

# Deploy до Cloud Run
gcloud run deploy myapp \
  --image gcr.io/PROJECT_ID/myapp:latest \
  --platform managed \
  --region us-central1 \
  --allow-unauthenticated \
  --set-env-vars NODE_ENV=production \
  --memory 512Mi \
  --cpu 1 \
  --max-instances 100</code></pre>
                        </div>

                        <h4>cloud-run.yaml</h4>
                        <div class="code-block">
                            <pre><code class="language-yaml">apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: myapp
  annotations:
    run.googleapis.com/ingress: all
spec:
  template:
    metadata:
      annotations:
        autoscaling.knative.dev/maxScale: "100"
        run.googleapis.com/cpu-throttling: "false"
        run.googleapis.com/memory: "512Mi"
    spec:
      containerConcurrency: 1000
      timeoutSeconds: 300
      containers:
      - image: gcr.io/PROJECT_ID/myapp:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: production
        resources:
          limits:
            cpu: 1000m
            memory: 512Mi
        startupProbe:
          httpGet:
            path: /health
            port: 3000
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3</code></pre>
                        </div>

                        <h4>Microsoft Azure</h4>
                        <p>Azure пропонує Container Instances та Azure Kubernetes Service.</p>

                        <h4>Розгортання на Azure Container Instances</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Створення resource group
az group create --name myapp-rg --location eastus

# Створення container registry
az acr create --resource-group myapp-rg --name myappregistry --sku Basic

# Build та push образу
az acr build --registry myappregistry --image myapp:latest .

# Deploy контейнера
az container create \
  --resource-group myapp-rg \
  --name myapp-container \
  --image myappregistry.azurecr.io/myapp:latest \
  --cpu 1 \
  --memory 1 \
  --registry-login-server myappregistry.azurecr.io \
  --registry-username myappregistry \
  --registry-password $(az acr credential show --name myappregistry --query "passwords[0].value" -o tsv) \
  --dns-name-label myapp-unique \
  --ports 3000 \
  --environment-variables 'NODE_ENV=production'</code></pre>
                        </div>

                        <h4>DigitalOcean App Platform</h4>
                        <p>Простий спосіб розгортання контейнерних додатків.</p>

                        <p><strong>.do/app.yaml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">name: myapp
services:
- name: web
  source_dir: /
  github:
    repo: username/myapp
    branch: main
  run_command: npm start
  environment_slug: node-js
  instance_count: 1
  instance_size_slug: basic-xxs
  http_port: 3000
  health_check:
    http_path: /health
  env:
  - key: NODE_ENV
    value: production
  - key: DATABASE_URL
    type: SECRET
databases:
- name: myapp-db
  engine: PG
  version: "13"
  size: db-s-dev-database</code></pre>
                        </div>

                        <h4>Порівняння хмарних платформ</h4>
                        <div class="content-table">
                            <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                                <thead>
                                    <tr style="background: #374151;">
                                        <th style="padding: 0.75rem; border: 1px solid #4b5563; color: #f8fafc;">Платформа</th>
                                        <th style="padding: 0.75rem; border: 1px solid #4b5563; color: #f8fafc;">Переваги</th>
                                        <th style="padding: 0.75rem; border: 1px solid #4b5563; color: #f8fafc;">Недоліки</th>
                                        <th style="padding: 0.75rem; border: 1px solid #4b5563; color: #f8fafc;">Ціна</th>
                                    </tr>
                                </thead>
                                <tbody style="color: #cbd5e1;">
                                    <tr>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">AWS</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Найбільший набір сервісів</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Складність налаштування</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Від $5/міс</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">GCP</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Добра інтеграція з Kubernetes</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Менше регіонів</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Від $4/міс</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Azure</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Добра інтеграція з Microsoft</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Менше документації</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Від $4/міс</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">DigitalOcean</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Простота використання</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Менше enterprise функцій</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Від $3/міс</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">💡 Вибір платформи</div>
                            <p>При виборі хмарної платформи враховуйте:</p>
                            <ul>
                                <li>Розмір та складність проекту</li>
                                <li>Бюджет та модель оплати</li>
                                <li>Географічне розташування користувачів</li>
                                <li>Потребу в специфічних сервісах</li>
                                <li>Досвід команди з конкретною платформою</li>
                            </ul>
                        </div>
                    </div>
                    <div id="8.3">
                        <h3 id="8.3">8.3 Моніторинг та логи</h3>
                        
                        <p>Моніторинг та збір логів є критично важливими для підтримки надійності продакшн системи.</p>

                        <h4>ELK Stack (Elasticsearch, Logstash, Kibana)</h4>
                        <p>Популярне рішення для збору, аналізу та візуалізації логів.</p>

                        <p><strong>docker-compose.monitoring.yml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  # Application
  app:
    build: .
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    labels:
      - "logging=true"

  # Elasticsearch
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.6.0
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      - xpack.security.enabled=false
    ports:
      - "9200:9200"
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data

  # Logstash
  logstash:
    image: docker.elastic.co/logstash/logstash:8.6.0
    volumes:
      - ./logstash/pipeline:/usr/share/logstash/pipeline:ro
      - ./logstash/config:/usr/share/logstash/config:ro
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock
    depends_on:
      - elasticsearch

  # Kibana
  kibana:
    image: docker.elastic.co/kibana/kibana:8.6.0
    ports:
      - "5601:5601"
    environment:
      ELASTICSEARCH_HOSTS: http://elasticsearch:9200
    depends_on:
      - elasticsearch

  # Prometheus
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'

  # Grafana
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      GF_SECURITY_ADMIN_PASSWORD: admin
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning
    depends_on:
      - prometheus

  # Node Exporter для системних метрик
  node-exporter:
    image: prom/node-exporter:latest
    ports:
      - "9100:9100"
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    command:
      - '--path.procfs=/host/proc'
      - '--path.sysfs=/host/sys'
      - '--collector.filesystem.ignored-mount-points=^/(sys|proc|dev|host|etc)($$|/)'

  # cAdvisor для метрик контейнерів
  cadvisor:
    image: gcr.io/cadvisor/cadvisor:latest
    ports:
      - "8080:8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:rw
      - /sys:/sys:ro
      - /var/lib/docker:/var/lib/docker:ro

volumes:
  elasticsearch_data:
  prometheus_data:
  grafana_data:</code></pre>
                        </div>

                        <h4>Logstash конфігурація</h4>
                        <p><strong>logstash/pipeline/logstash.conf</strong></p>
                        <div class="code-block">
                            <pre><code class="language-ruby">input {
  # Docker logs
  file {
    path => "/var/lib/docker/containers/*/*.log"
    start_position => "beginning"
    codec => json
    type => "docker"
  }
}

filter {
  if [type] == "docker" {
    # Parse Docker log format
    if [log] {
      mutate {
        rename => { "log" => "message" }
      }
    }

    # Extract container information
    grok {
      match => { "source" => "/var/lib/docker/containers/%{DATA:container_id}/%{GREEDYDATA}" }
    }

    # Parse application logs
    if [message] =~ /^\{.*\}$/ {
      json {
        source => "message"
      }
    } else {
      grok {
        match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{GREEDYDATA:log_message}" }
      }
    }

    # Add hostname
    mutate {
      add_field => { "hostname" => "%{HOST}" }
    }

    # Convert timestamp
    date {
      match => [ "timestamp", "ISO8601" ]
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "docker-logs-%{+YYYY.MM.dd}"
  }

  # Debug output
  stdout {
    codec => rubydebug
  }
}</code></pre>
                        </div>

                        <h4>Prometheus конфігурація</h4>
                        <p><strong>prometheus/prometheus.yml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

scrape_configs:
  # Prometheus self-monitoring
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  # Node Exporter for system metrics
  - job_name: 'node-exporter'
    static_configs:
      - targets: ['node-exporter:9100']

  # cAdvisor for container metrics
  - job_name: 'cadvisor'
    static_configs:
      - targets: ['cadvisor:8080']

  # Application metrics
  - job_name: 'myapp'
    static_configs:
      - targets: ['app:3000']
    metrics_path: '/metrics'
    scrape_interval: 5s

  # Docker daemon metrics
  - job_name: 'docker'
    static_configs:
      - targets: ['host.docker.internal:9323']</code></pre>
                        </div>

                        <h4>Alerting правила</h4>
                        <p><strong>prometheus/alert_rules.yml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">groups:
  - name: docker_alerts
    rules:
      - alert: ContainerDown
        expr: up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Container {{ $labels.instance }} is down"
        labels:
          severity: warning
        annotations:
          summary: "High memory usage on {{ $labels.name }}"
          description: "Container memory usage is above 80%"

      - alert: HighCPUUsage
        expr: (rate(container_cpu_usage_seconds_total[5m]) * 100) > 80
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "High CPU usage on {{ $labels.name }}"
          description: "Container CPU usage is above 80%"

      - alert: DiskSpaceLow
        expr: (1 - (node_filesystem_avail_bytes / node_filesystem_size_bytes)) * 100 > 85
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Low disk space on {{ $labels.instance }}"
          description: "Disk space usage is above 85%"</code></pre>
                        </div>

                        <h4>Structured logging в додатку</h4>
                        <p><strong>Приклад для Node.js з Winston:</strong></p>
                        <div class="code-block">
                            <pre><code class="language-javascript">const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { 
    service: 'myapp',
    version: process.env.APP_VERSION || '1.0.0',
    environment: process.env.NODE_ENV || 'development'
  },
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    }),
    new winston.transports.File({ 
      filename: '/var/log/app/error.log', 
      level: 'error' 
    }),
    new winston.transports.File({ 
      filename: '/var/log/app/combined.log' 
    })
  ]
});

// HTTP request middleware
const requestLogger = (req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    
    logger.info('HTTP Request', {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration: duration,
      userAgent: req.get('User-Agent'),
      ip: req.ip,
      userId: req.user?.id
    });
  });
  
  next();
};

// Error handler
const errorHandler = (error, req, res, next) => {
  logger.error('Application Error', {
    error: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    userId: req.user?.id,
    requestId: req.id
  });
  
  res.status(500).json({ 
    error: 'Internal Server Error',
    requestId: req.id 
  });
};

module.exports = { logger, requestLogger, errorHandler };</code></pre>
                        </div>

                        <h4>Health checks та readiness probes</h4>
                        <div class="code-block">
                            <pre><code class="language-javascript">// health.js
const express = require('express');
const { logger } = require('./logger');

const router = express.Router();

// Basic health check
router.get('/health', (req, res) => {
  res.json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    version: process.env.APP_VERSION
  });
});

// Detailed health check
router.get('/health/detailed', async (req, res) => {
  const checks = {
    database: await checkDatabase(),
    redis: await checkRedis(),
    memory: checkMemory(),
    disk: await checkDisk()
  };
  
  const allHealthy = Object.values(checks).every(check => check.status === 'OK');
  
  const response = {
    status: allHealthy ? 'OK' : 'DEGRADED',
    timestamp: new Date().toISOString(),
    checks: checks
  };
  
  logger.info('Health Check Performed', response);
  
  res.status(allHealthy ? 200 : 503).json(response);
});

async function checkDatabase() {
  try {
    // Perform database connectivity check
    await db.query('SELECT 1');
    return { status: 'OK', responseTime: Date.now() - start };
  } catch (error) {
    return { status: 'ERROR', error: error.message };
  }
}

async function checkRedis() {
  try {
    const start = Date.now();
    await redis.ping();
    return { status: 'OK', responseTime: Date.now() - start };
  } catch (error) {
    return { status: 'ERROR', error: error.message };
  }
}

function checkMemory() {
  const used = process.memoryUsage();
  const limit = 512 * 1024 * 1024; // 512MB
  
  return {
    status: used.heapUsed < limit * 0.9 ? 'OK' : 'WARNING',
    heapUsed: used.heapUsed,
    heapTotal: used.heapTotal,
    limit: limit
  };
}

module.exports = router;</code></pre>
                        </div>

                        <h4>Grafana dashboard</h4>
                        <p><strong>grafana/provisioning/dashboards/docker-dashboard.json</strong> (фрагмент):</p>
                        <div class="code-block">
                            <pre><code class="language-json">{
  "dashboard": {
    "id": null,
    "title": "Docker Monitoring",
    "panels": [
      {
        "title": "Container CPU Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(container_cpu_usage_seconds_total[5m]) * 100",
            "legendFormat": "{{ name }}"
          }
        ]
      },
      {
        "title": "Container Memory Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "container_memory_usage_bytes / 1024 / 1024",
            "legendFormat": "{{ name }}"
          }
        ]
      },
      {
        "title": "HTTP Requests per Second",
        "type": "stat",
        "targets": [
          {
            "expr": "rate(http_requests_total[1m])",
            "legendFormat": "RPS"
          }
        ]
      }
    ]
  }
}</code></pre>
                        </div>

                        <h4>Практичні поради по моніторингу</h4>
                        <div class="info-box">
                            <div class="info-box-title">📊 Best Practices для моніторингу</div>
                            <ul>
                                <li><strong>Golden Signals</strong>: відстежуйте Latency, Traffic, Errors, Saturation</li>
                                <li><strong>SLI/SLO</strong>: визначте Service Level Indicators та Objectives</li>
                                <li><strong>Alerting</strong>: налаштуйте алерти для критичних метрик</li>
                                <li><strong>Log retention</strong>: плануйте стратегію зберігання логів</li>
                                <li><strong>Dashboards</strong>: створюйте зрозумілі та корисні дашборди</li>
                                <li><strong>Cost optimization</strong>: оптимізуйте витрати на зберігання метрик</li>
                            </ul>
                        </div>

                        <h4>Команди для роботи з логами</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Переглянути логи контейнера
docker logs myapp-container

# Стежити за логами в реальному часі
docker logs -f myapp-container

# Переглянути останні 100 рядків
docker logs --tail 100 myapp-container

# Логи з timestamps
docker logs -t myapp-container

# Логи з Docker Compose
docker-compose logs myapp

# Експорт логів
docker logs myapp-container > myapp.log 2>&1

# Статистика контейнера
docker stats myapp-container

# Детальна інформація про контейнер
docker inspect myapp-container</code></pre>
                        </div>

                        <div class="info-box warning">
                            <div class="info-box-title">⚠️ Важливо</div>
                            <p>При налаштуванні моніторингу в продакшні враховуйте:</p>
                            <ul>
                                <li>Безпеку - захистіть доступ до метрик та логів</li>
                                <li>Продуктивність - моніторинг не повинен суттєво впливати на додаток</li>
                                <li>Costs - оптимізуйте витрати на зберігання та обробку даних</li>
                                <li>Compliance - дотримуйтесь вимог до зберігання даних</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div id="9">
                    <h2>9. Просунуті теми</h2>
                    <div id="9.1">
                        <h3 id="9.1">9.1 Безпека контейнерів</h3>
                        
                        <p>Безпека контейнерів є критично важливою для продакшн систем. Розглянемо основні принципи та практики.</p>

                        <h4>Принципи безпеки контейнерів</h4>
                        <div class="info-box">
                            <div class="info-box-title">🔒 Основні принципи</div>
                            <ul>
                                <li><strong>Least privilege</strong> - мінімальні привілеї для контейнерів</li>
                                <li><strong>Defense in depth</strong> - багаторівневий захист</li>
                                <li><strong>Image scanning</strong> - сканування образів на вразливості</li>
                                <li><strong>Runtime security</strong> - захист під час виконання</li>
                                <li><strong>Network segmentation</strong> - ізоляція мережевого трафіку</li>
                                <li><strong>Secrets management</strong> - безпечне зберігання секретів</li>
                            </ul>
                        </div>

                        <h4>Безпечний Dockerfile</h4>
                        <p>Приклад безпечного Dockerfile з коментарями:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Використовуємо офіційний образ з конкретною версією
FROM node:18.17.0-alpine3.18

# Встановлюємо мітки для метаданих
LABEL maintainer="security@company.com"
LABEL version="1.0.0"
LABEL description="Secure Node.js application"

# Оновлюємо пакети та встановлюємо тільки необхідне
RUN apk update && \
    apk upgrade && \
    apk add --no-cache \
        dumb-init \
        su-exec && \
    rm -rf /var/cache/apk/*

# Створюємо непривілейованого користувача
RUN addgroup -g 1001 -S appgroup && \
    adduser -S -D -H -u 1001 -s /sbin/nologin -G appgroup appuser

# Встановлюємо робочу директорію
WORKDIR /app

# Копіюємо package.json та встановлюємо залежності
COPY package*.json ./
RUN npm ci --only=production && \
    npm cache clean --force && \
    npm audit fix

# Копіюємо код додатку
COPY --chown=appuser:appgroup . .

# Видаляємо непотрібні файли
RUN rm -rf \
    .git \
    .gitignore \
    README.md \
    Dockerfile \
    .dockerignore \
    node_modules/*/test \
    node_modules/*/tests \
    node_modules/*/*.md

# Встановлюємо права доступу
RUN chmod -R 755 /app && \
    chown -R appuser:appgroup /app

# Переключаємось на непривілейованого користувача
USER appuser

# Відкриваємо порт (>1024 для непривілейованого користувача)
EXPOSE 3000

# Встановлюємо health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js || exit 1

# Використовуємо dumb-init для правильної обробки сигналів
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "server.js"]</code></pre>
                        </div>

                        <h4>Сканування образів на вразливості</h4>
                        <p>Використання різних інструментів для перевірки безпеки:</p>

                        <div class="code-block">
                            <pre><code class="language-bash"># Docker Scout (вбудований в Docker Desktop)
docker scout cves myapp:latest
docker scout recommendations myapp:latest

# Trivy - популярний open-source сканер
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
  aquasec/trivy image myapp:latest

# Snyk
snyk container test myapp:latest

# Anchore Grype
grype myapp:latest</code></pre>
                        </div>

                        <h4>Secrets Management</h4>
                        <p>Безпечне управління секретами:</p>

                        <div class="code-block">
                            <pre><code class="language-bash"># Створення секрету з файлу
echo "my_secret_password" | docker secret create db_password -

# Використання секретів у Docker Compose
version: '3.8'
services:
  app:
    image: myapp:latest
    secrets:
      - db_password
      - api_key
    environment:
      - DB_PASSWORD_FILE=/run/secrets/db_password
      - API_KEY_FILE=/run/secrets/api_key

secrets:
  db_password:
    external: true
  api_key:
    external: true</code></pre>
                        </div>

                        <h4>Security scanning скрипт</h4>
                        <div class="code-block">
                            <pre><code class="language-bash">#!/bin/bash
echo "🔍 Security Check Started"

# Перевірка на запуск від root
docker ps --format "{{.Names}}" | while read name; do
  if [ "$name" != "NAMES" ]; then
    user=$(docker exec $name whoami 2>/dev/null || echo "unknown")
    if [ "$user" = "root" ]; then
      echo "⚠️  WARNING: $name running as root"
    else
      echo "✅ $name running as: $user"
    fi
  fi
done

# Перевірка на privileged контейнери
docker ps --format "{{.Names}}" | xargs -I {} docker inspect {} \
  --format '{{.Name}}: Privileged={{.HostConfig.Privileged}}' | \
  grep "true" && echo "⚠️  Privileged containers found!" || echo "✅ No privileged containers"

echo "🔍 Security Check Completed"</code></pre>
                        </div>

                        <div class="info-box warning">
                            <div class="info-box-title">⚠️ Безпечні практики</div>
                            <ul>
                                <li>Ніколи не зберігайте секрети в образах</li>
                                <li>Використовуйте multi-stage builds</li>
                                <li>Регулярно оновлюйте базові образи</li>
                                <li>Обмежуйте ресурси контейнерів</li>
                                <li>Використовуйте read-only файлові системи</li>
                                <li>Налаштуйте належне логування</li>
                                <li>Проводьте регулярні security audits</li>
                            </ul>
                        </div>
                    </div>
                    <div id="9.2">
                        <h3 id="9.2">9.2 CI/CD з Docker</h3>
                        
                        <p>Інтеграція Docker у CI/CD pipeline забезпечує консистентність між середовищами розробки, тестування та продакшну.</p>

                        <h4>GitHub Actions з Docker</h4>
                        <p>Приклад повного CI/CD pipeline:</p>

                        <p><strong>.github/workflows/docker-ci-cd.yml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">name: Docker CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build test image
        uses: docker/build-push-action@v5
        with:
          context: .
          target: test
          load: true
          tags: myapp:test
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Run tests
        run: |
          docker run --rm myapp:test npm test
          docker run --rm myapp:test npm run lint
          docker run --rm myapp:test npm audit

      - name: Security scan
        run: |
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy image myapp:test

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Deploy to production
        run: |
          echo "Deploying to production server..."
          # SSH to production server and update containers</code></pre>
                        </div>

                        <h4>Multi-stage Dockerfile для CI/CD</h4>
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Базовий образ для всіх стадій
FROM node:18-alpine AS base
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# Стадія для розробки
FROM base AS development
RUN npm ci
COPY . .
EXPOSE 3000
CMD ["npm", "run", "dev"]

# Стадія для тестування
FROM development AS test
RUN npm run lint
RUN npm run test:unit
RUN npm audit
CMD ["npm", "test"]

# Стадія збірки
FROM development AS build
RUN npm run build

# Продакшн стадія
FROM nginx:alpine AS production
COPY --from=build /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]

# Node.js продакшн стадія
FROM base AS production-node
COPY --from=build /app/dist ./dist
COPY --from=build /app/package*.json ./
USER node
EXPOSE 3000
CMD ["node", "dist/server.js"]</code></pre>
                        </div>

                        <h4>GitLab CI з Docker</h4>
                        <p><strong>.gitlab-ci.yml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
  LATEST_TAG: $CI_REGISTRY_IMAGE:latest

stages:
  - test
  - build
  - security
  - deploy

services:
  - docker:dind

before_script:
  - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY

test:
  stage: test
  image: docker:latest
  script:
    - docker build --target test -t myapp:test .
    - docker run --rm myapp:test npm test
    - docker run --rm myapp:test npm run lint
  coverage: '/Coverage: \d+\.\d+%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml

build:
  stage: build
  image: docker:latest
  script:
    - docker build --target production -t $IMAGE_TAG .
    - docker tag $IMAGE_TAG $LATEST_TAG
    - docker push $IMAGE_TAG
    - docker push $LATEST_TAG
  only:
    - main
    - develop

security-scan:
  stage: security
  image: docker:latest
  script:
    - docker run --rm -v /var/run/docker.sock:/var/run/docker.sock 
        aquasec/trivy image $IMAGE_TAG
  allow_failure: true
  only:
    - main

deploy-staging:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - curl -X POST "$WEBHOOK_URL_STAGING" 
        -H "Content-Type: application/json" 
        -d '{"image":"'$IMAGE_TAG'"}'
  environment:
    name: staging
    url: https://staging.myapp.com
  only:
    - develop

deploy-production:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - curl -X POST "$WEBHOOK_URL_PRODUCTION" 
        -H "Content-Type: application/json" 
        -d '{"image":"'$IMAGE_TAG'"}'
  environment:
    name: production
    url: https://myapp.com
  when: manual
  only:
    - main</code></pre>
                        </div>

                        <h4>Jenkins Pipeline з Docker</h4>
                        <p><strong>Jenkinsfile</strong></p>
                        <div class="code-block">
                            <pre><code class="language-groovy">pipeline {
    agent any
    
    environment {
        DOCKER_REGISTRY = 'your-registry.com'
        IMAGE_NAME = 'myapp'
        IMAGE_TAG = "${BUILD_NUMBER}"
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Test') {
            steps {
                script {
                    sh 'docker build --target test -t ${IMAGE_NAME}:test .'
                    sh 'docker run --rm ${IMAGE_NAME}:test npm test'
                    sh 'docker run --rm ${IMAGE_NAME}:test npm run lint'
                }
            }
            post {
                always {
                    publishTestResults testResultsPattern: 'test-results.xml'
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'coverage',
                        reportFiles: 'index.html',
                        reportName: 'Coverage Report'
                    ])
                }
            }
        }
        
        stage('Security Scan') {
            steps {
                script {
                    sh '''
                        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
                            aquasec/trivy image ${IMAGE_NAME}:test > security-report.txt
                    '''
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'security-report.txt'
                }
            }
        }
        
        stage('Build') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                }
            }
            steps {
                script {
                    sh '''
                        docker build --target production \
                            -t ${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG} \
                            -t ${DOCKER_REGISTRY}/${IMAGE_NAME}:latest .
                    '''
                }
            }
        }
        
        stage('Push') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                }
            }
            steps {
                script {
                    docker.withRegistry("https://${DOCKER_REGISTRY}", 'docker-registry-credentials') {
                        sh '''
                            docker push ${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}
                            docker push ${DOCKER_REGISTRY}/${IMAGE_NAME}:latest
                        '''
                    }
                }
            }
        }
        
        stage('Deploy to Staging') {
            when {
                branch 'develop'
            }
            steps {
                script {
                    sh '''
                        docker-compose -f docker-compose.staging.yml pull
                        docker-compose -f docker-compose.staging.yml up -d
                    '''
                }
            }
        }
        
        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            steps {
                input message: 'Deploy to production?', ok: 'Deploy'
                script {
                    sh '''
                        docker-compose -f docker-compose.prod.yml pull
                        docker-compose -f docker-compose.prod.yml up -d
                    '''
                }
            }
        }
    }
    
    post {
        always {
            sh 'docker system prune -f'
        }
        success {
            slackSend(
                color: 'good',
                message: "✅ Pipeline succeeded: ${env.JOB_NAME} - ${env.BUILD_NUMBER}"
            )
        }
        failure {
            slackSend(
                color: 'danger',
                message: "❌ Pipeline failed: ${env.JOB_NAME} - ${env.BUILD_NUMBER}"
            )
        }
    }
}</code></pre>
                        </div>

                        <h4>Docker-in-Docker (DinD) для CI</h4>
                        <div class="code-block">
                            <pre><code class="language-yaml"># docker-compose.ci.yml для локального тестування CI
version: '3.8'

services:
  jenkins:
    image: jenkins/jenkins:lts
    ports:
      - "8080:8080"
      - "50000:50000"
    volumes:
      - jenkins_home:/var/jenkins_home
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - DOCKER_HOST=unix:///var/run/docker.sock
    user: root

  gitlab-runner:
    image: gitlab/gitlab-runner:latest
    volumes:
      - gitlab_runner_config:/etc/gitlab-runner
      - /var/run/docker.sock:/var/run/docker.sock
    command: >
      bash -c "
        gitlab-runner register
          --non-interactive
          --url https://gitlab.com/
          --registration-token YOUR_TOKEN
          --executor docker
          --docker-image alpine:latest
          --docker-privileged true
          --docker-volumes '/var/run/docker.sock:/var/run/docker.sock'
        && gitlab-runner run
      "

volumes:
  jenkins_home:
  gitlab_runner_config:</code></pre>
                        </div>

                        <h4>Кешування в CI/CD</h4>
                        <div class="code-block">
                            <pre><code class="language-dockerfile"># Dockerfile з оптимізованим кешуванням
FROM node:18-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

FROM node:18-alpine AS dev-deps
WORKDIR /app
COPY package*.json ./
RUN npm ci

FROM dev-deps AS build
COPY . .
RUN npm run build

FROM deps AS runtime
COPY --from=build /app/dist ./dist
USER node
CMD ["node", "dist/server.js"]</code></pre>
                        </div>

                        <h4>Automated deployment script</h4>
                        <p><strong>deploy.sh</strong></p>
                        <div class="code-block">
                            <pre><code class="language-bash">#!/bin/bash
set -e

# Configuration
IMAGE_NAME="myapp"
REGISTRY="your-registry.com"
ENVIRONMENT=${1:-staging}
VERSION=${2:-latest}

echo "🚀 Starting deployment to $ENVIRONMENT"
echo "📦 Image: $REGISTRY/$IMAGE_NAME:$VERSION"

# Pull latest image
echo "📥 Pulling latest image..."
docker pull $REGISTRY/$IMAGE_NAME:$VERSION

# Health check function
health_check() {
    local service_name=$1
    local max_attempts=30
    local attempt=1
    
    echo "🔍 Checking health of $service_name..."
    
    while [ $attempt -le $max_attempts ]; do
        if curl -f -s http://localhost:3000/health > /dev/null; then
            echo "✅ $service_name is healthy"
            return 0
        fi
        
        echo "⏳ Attempt $attempt/$max_attempts failed, waiting..."
        sleep 10
        attempt=$((attempt + 1))
    done
    
    echo "❌ Health check failed for $service_name"
    return 1
}

# Deploy with zero-downtime
echo "🔄 Performing zero-downtime deployment..."

# Start new container
docker run -d \
    --name ${IMAGE_NAME}_new \
    --network myapp_network \
    -e NODE_ENV=$ENVIRONMENT \
    $REGISTRY/$IMAGE_NAME:$VERSION

# Wait for new container to be ready
if health_check "${IMAGE_NAME}_new"; then
    # Update load balancer to point to new container
    echo "🔄 Updating load balancer..."
    
    # Stop old container
    docker stop ${IMAGE_NAME}_old 2>/dev/null || true
    docker rm ${IMAGE_NAME}_old 2>/dev/null || true
    
    # Rename containers
    docker rename $IMAGE_NAME ${IMAGE_NAME}_old 2>/dev/null || true
    docker rename ${IMAGE_NAME}_new $IMAGE_NAME
    
    # Remove old container
    docker stop ${IMAGE_NAME}_old 2>/dev/null || true
    docker rm ${IMAGE_NAME}_old 2>/dev/null || true
    
    echo "✅ Deployment completed successfully!"
else
    echo "❌ Deployment failed, rolling back..."
    docker stop ${IMAGE_NAME}_new
    docker rm ${IMAGE_NAME}_new
    exit 1
fi

# Cleanup old images
echo "🧹 Cleaning up old images..."
docker image prune -f

echo "🎉 Deployment to $ENVIRONMENT completed!"</code></pre>
                        </div>

                        <div class="info-box">
                            <div class="info-box-title">💡 CI/CD Best Practices</div>
                            <ul>
                                <li>Використовуйте multi-stage builds для оптимізації</li>
                                <li>Кешуйте залежності між build'ами</li>
                                <li>Запускайте тести на кожному commit</li>
                                <li>Сканируйте образи на вразливості</li>
                                <li>Автоматизуйте деплоймент тільки після успішних тестів</li>
                                <li>Використовуйте semantic versioning для тегів</li>
                                <li>Впроваджуйте zero-downtime deployment</li>
                                <li>Налаштуйте моніторинг та alerting</li>
                            </ul>
                        </div>
                    </div>
                    <div id="9.3">
                        <h3 id="9.3">9.3 Docker Swarm</h3>
                        
                        <p>Docker Swarm - це вбудований інструмент оркестрації контейнерів, який дозволяє управляти кластером Docker вузлів.</p>

                        <h4>Основи Docker Swarm</h4>
                        <div class="info-box">
                            <div class="info-box-title">🔧 Основні концепції Swarm</div>
                            <ul>
                                <li><strong>Node</strong> - окремий Docker engine в кластері</li>
                                <li><strong>Manager Node</strong> - керує кластером та приймає рішення</li>
                                <li><strong>Worker Node</strong> - виконує завдання (tasks)</li>
                                <li><strong>Service</strong> - визначення застосунку в кластері</li>
                                <li><strong>Task</strong> - окремий контейнер в сервісі</li>
                                <li><strong>Stack</strong> - група пов'язаних сервісів</li>
                            </ul>
                        </div>

                        <h4>Створення Swarm кластера</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Ініціалізація Swarm на головному вузлі
docker swarm init --advertise-addr 192.168.1.100

# Отримання токену для приєднання worker вузлів
docker swarm join-token worker

# Отримання токену для приєднання manager вузлів
docker swarm join-token manager

# Приєднання worker вузла до кластера
docker swarm join --token SWMTKN-1-... 192.168.1.100:2377

# Перегляд вузлів кластера
docker node ls

# Перегляд детальної інформації про вузол
docker node inspect self --pretty</code></pre>
                        </div>

                        <h4>Створення та управління сервісами</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Створення простого сервісу
docker service create --name web-server \
  --replicas 3 \
  --publish 80:80 \
  nginx:alpine

# Створення сервісу з детальними параметрами
docker service create \
  --name myapp \
  --replicas 5 \
  --publish 3000:3000 \
  --env NODE_ENV=production \
  --env DATABASE_URL=postgresql://... \
  --constraint 'node.role == worker' \
  --limit-memory 512M \
  --limit-cpu 0.5 \
  --reserve-memory 256M \
  --reserve-cpu 0.25 \
  --restart-condition on-failure \
  --restart-max-attempts 3 \
  --update-delay 10s \
  --update-parallelism 2 \
  myapp:latest

# Перегляд сервісів
docker service ls

# Детальна інформація про сервіс
docker service inspect myapp --pretty

# Перегляд логів сервісу
docker service logs myapp

# Масштабування сервісу
docker service scale myapp=10

# Оновлення сервісу
docker service update --image myapp:v2 myapp

# Rolling update з конфігурацією
docker service update \
  --image myapp:v2 \
  --update-parallelism 2 \
  --update-delay 30s \
  --update-failure-action rollback \
  myapp

# Видалення сервісу
docker service rm myapp</code></pre>
                        </div>

                        <h4>Docker Stack (docker-compose для Swarm)</h4>
                        <p><strong>docker-stack.yml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">version: '3.8'

services:
  # Load balancer
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - nginx_conf:/etc/nginx/conf.d
      - nginx_ssl:/etc/nginx/ssl
    networks:
      - frontend
    deploy:
      replicas: 2
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          memory: 256M
        reservations:
          memory: 128M
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3

  # Web application
  app:
    image: myapp:latest
    networks:
      - frontend
      - backend
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://postgres:5432/myapp
      - REDIS_URL=redis://redis:6379
    secrets:
      - db_password
      - jwt_secret
    deploy:
      replicas: 6
      placement:
        constraints:
          - node.role == worker
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.25'
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 3
      update_config:
        parallelism: 2
        delay: 30s
        failure_action: rollback
        monitor: 60s
      rollback_config:
        parallelism: 1
        delay: 10s

  # Database
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD_FILE: /run/secrets/db_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - backend
    secrets:
      - db_password
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.labels.storage == ssd
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M
      restart_policy:
        condition: on-failure

  # Redis cache
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    networks:
      - backend
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.role == worker
      resources:
        limits:
          memory: 256M
        reservations:
          memory: 128M

  # Background worker
  worker:
    image: myapp:latest
    command: npm run worker
    networks:
      - backend
    environment:
      - NODE_ENV=production
      - REDIS_URL=redis://redis:6379
    secrets:
      - db_password
    deploy:
      replicas: 3
      placement:
        constraints:
          - node.role == worker
      resources:
        limits:
          memory: 256M
        reservations:
          memory: 128M

  # Monitoring
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - prometheus_config:/etc/prometheus
      - prometheus_data:/prometheus
    networks:
      - monitoring
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          memory: 1G

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3001:3000"
    environment:
      GF_SECURITY_ADMIN_PASSWORD: admin
    volumes:
      - grafana_data:/var/lib/grafana
    networks:
      - monitoring
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.role == manager

networks:
  frontend:
    driver: overlay
    attachable: true
  backend:
    driver: overlay
  monitoring:
    driver: overlay

volumes:
  postgres_data:
  redis_data:
  nginx_conf:
  nginx_ssl:
  prometheus_config:
  prometheus_data:
  grafana_data:

secrets:
  db_password:
    external: true
  jwt_secret:
    external: true</code></pre>
                        </div>

                        <h4>Управління Stack</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Створення секретів
echo "my_database_password" | docker secret create db_password -
echo "my_jwt_secret_key" | docker secret create jwt_secret -

# Додавання міток до вузлів
docker node update --label-add storage=ssd node-1
docker node update --label-add storage=hdd node-2

# Розгортання stack
docker stack deploy -c docker-stack.yml myapp

# Перегляд stacks
docker stack ls

# Перегляд сервісів в stack
docker stack services myapp

# Перегляд tasks в stack
docker stack ps myapp

# Оновлення stack
docker stack deploy -c docker-stack.yml myapp

# Видалення stack
docker stack rm myapp</code></pre>
                        </div>

                        <h4>Load Balancing та Service Discovery</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Swarm автоматично розподіляє навантаження між репліками
# Кожен сервіс має внутрішню DNS назву

# Приклад конфігурації Nginx для load balancing
upstream app_servers {
    server app:3000;  # Swarm DNS резолвить до всіх реплік
}

server {
    listen 80;
    location / {
        proxy_pass http://app_servers;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}</code></pre>
                        </div>

                        <h4>Health Checks у Swarm</h4>
                        <div class="code-block">
                            <pre><code class="language-yaml"># В docker-stack.yml
services:
  app:
    image: myapp:latest
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    deploy:
      replicas: 3
      update_config:
        # Swarm буде чекати на healthy стан перед оновленням наступної репліки
        monitor: 60s
        failure_action: rollback</code></pre>
                        </div>

                        <h4>Swarm Routing Mesh</h4>
                        <p>Swarm автоматично маршрутизує трафік між усіма вузлами:</p>
                        
                        <div class="code-block">
                            <pre><code class="language-bash"># Сервіс доступний на всіх вузлах кластера
# навіть якщо контейнер працює тільки на одному вузлі

# Створення сервісу з опублікованим портом
docker service create \
  --name web \
  --publish published=8080,target=80 \
  --replicas 3 \
  nginx

# Тепер web сервіс доступний на порту 8080 
# на всіх вузлах кластера</code></pre>
                        </div>

                        <h4>Моніторинг Swarm кластера</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Перегляд стану кластера
docker node ls
docker service ls
docker stack ls

# Детальна інформація про задачі
docker service ps myapp --no-trunc

# Логи сервісу з усіх реплік
docker service logs -f myapp

# Статистика ресурсів
docker stats $(docker ps -q)

# Інформація про overlay мережі
docker network ls --filter driver=overlay
docker network inspect myapp_frontend</code></pre>
                        </div>

                        <h4>Backup та відновлення Swarm</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Backup Swarm state (на manager вузлі)
sudo systemctl stop docker
sudo tar -czf swarm-backup.tar.gz -C /var/lib/docker/swarm ./
sudo systemctl start docker

# Відновлення з backup
sudo systemctl stop docker
sudo rm -rf /var/lib/docker/swarm
sudo tar -xzf swarm-backup.tar.gz -C /var/lib/docker/
sudo systemctl start docker

# Форсоване переініціалізація кластера
docker swarm init --force-new-cluster --advertise-addr $(hostname -i)</code></pre>
                        </div>

                        <h4>Практичні поради для Swarm</h4>
                        <div class="info-box">
                            <div class="info-box-title">💡 Best Practices для Docker Swarm</div>
                            <ul>
                                <li>Використовуйте непарну кількість manager вузлів (3, 5, 7)</li>
                                <li>Розміщуйте manager вузли в різних зонах доступності</li>
                                <li>Використовуйте constraints для контролю розміщення</li>
                                <li>Налаштуйте health checks для всіх сервісів</li>
                                <li>Використовуйте secrets для чутливих даних</li>
                                <li>Регулярно робіть backup стану Swarm</li>
                                <li>Моніторте ресурси та продуктивність кластера</li>
                                <li>Плануйте стратегію disaster recovery</li>
                            </ul>
                        </div>

                        <div class="info-box warning">
                            <div class="info-box-title">⚠️ Обмеження Docker Swarm</div>
                            <ul>
                                <li>Менш функціональний ніж Kubernetes</li>
                                <li>Обмежені можливості автоскейлінгу</li>
                                <li>Немає підтримки StatefulSets</li>
                                <li>Обмежені мережеві політики</li>
                                <li>Менша екосистема інструментів</li>
                            </ul>
                        </div>
                    </div>
                    <div id="9.4">
                        <h3 id="9.4">9.4 Kubernetes вступ</h3>
                        
                        <p>Kubernetes (K8s) - найпопулярніша система оркестрації контейнерів, що забезпечує автоматизацію розгортання, масштабування та управління контейнеризованими додатками.</p>

                        <h4>Основні концепції Kubernetes</h4>
                        <div class="info-box">
                            <div class="info-box-title">🎯 Ключові компоненти K8s</div>
                            <ul>
                                <li><strong>Pod</strong> - найменша одиниця розгортання</li>
                                <li><strong>Service</strong> - мережевий доступ до Pods</li>
                                <li><strong>Deployment</strong> - управління репліками Pods</li>
                                <li><strong>Namespace</strong> - логічне поділення кластера</li>
                                <li><strong>ConfigMap/Secret</strong> - конфігурація та секрети</li>
                                <li><strong>Ingress</strong> - HTTP/HTTPS маршрутизація</li>
                                <li><strong>Volume</strong> - зберігання даних</li>
                            </ul>
                        </div>

                        <h4>Порівняння Docker Swarm vs Kubernetes</h4>
                        <div class="content-table">
                            <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                                <thead>
                                    <tr style="background: #374151;">
                                        <th style="padding: 0.75rem; border: 1px solid #4b5563; color: #f8fafc;">Критерій</th>
                                        <th style="padding: 0.75rem; border: 1px solid #4b5563; color: #f8fafc;">Docker Swarm</th>
                                        <th style="padding: 0.75rem; border: 1px solid #4b5563; color: #f8fafc;">Kubernetes</th>
                                    </tr>
                                </thead>
                                <tbody style="color: #cbd5e1;">
                                    <tr>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Складність</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Простий в освоєнні</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Крута крива навчання</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Функціональність</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Базова оркестрація</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Повноцінна платформа</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Автоскейлінг</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Ручне масштабування</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Автоматичне HPA/VPA</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Екосистема</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Обмежена</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Величезна екосистема</td>
                                    </tr>
                                    <tr>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Multi-cloud</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Обмежена підтримка</td>
                                        <td style="padding: 0.75rem; border: 1px solid #4b5563;">Відмінна підтримка</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <h4>Міграція з Docker Compose до Kubernetes</h4>
                        <p>Kubernetes маніфести для того ж додатку:</p>

                        <p><strong>deployment.yaml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  labels:
    app: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: myapp-secrets
              key: database-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 5
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10</code></pre>
                        </div>

                        <p><strong>service.yaml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: myapp-service
  labels:
    app: myapp
spec:
  type: ClusterIP
  ports:
  - port: 80
    targetPort: 3000
    protocol: TCP
  selector:
    app: myapp

---
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
spec:
  type: ClusterIP
  ports:
  - port: 5432
    targetPort: 5432
  selector:
    app: postgres</code></pre>
                        </div>

                        <p><strong>ingress.yaml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: myapp-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - myapp.example.com
    secretName: myapp-tls
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: myapp-service
            port:
              number: 80</code></pre>
                        </div>

                        <p><strong>configmap-secret.yaml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: myapp-config
data:
  NODE_ENV: "production"
  LOG_LEVEL: "info"
  REDIS_HOST: "redis-service"
  REDIS_PORT: "6379"

---
apiVersion: v1
kind: Secret
metadata:
  name: myapp-secrets
type: Opaque
data:
  database-url: cG9zdGdyZXNxbDovL3VzZXI6cGFzcw== # base64 encoded
  jwt-secret: bXlfc2VjcmV0X2p3dF9rZXk=           # base64 encoded</code></pre>
                        </div>

                        <h4>Kubernetes команди</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Застосування маніфестів
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
kubectl apply -f ingress.yaml

# Або застосувати всі файли в директорії
kubectl apply -f k8s/

# Перегляд ресурсів
kubectl get pods
kubectl get services
kubectl get deployments
kubectl get ingress

# Детальна інформація
kubectl describe pod myapp-xxx
kubectl describe service myapp-service

# Логи подів
kubectl logs -f deployment/myapp
kubectl logs myapp-pod-xxx --previous

# Масштабування
kubectl scale deployment myapp --replicas=5

# Rolling update
kubectl set image deployment/myapp myapp=myapp:v2
kubectl rollout status deployment/myapp
kubectl rollout history deployment/myapp
kubectl rollout undo deployment/myapp

# Перехід в под
kubectl exec -it myapp-pod-xxx -- /bin/bash

# Port forwarding для локального доступу
kubectl port-forward service/myapp-service 3000:80

# Видалення ресурсів
kubectl delete -f deployment.yaml
kubectl delete deployment myapp</code></pre>
                        </div>

                        <h4>Helm - пакетний менеджер для Kubernetes</h4>
                        <p>Helm спрощує управління Kubernetes додатками:</p>

                        <p><strong>Chart.yaml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">apiVersion: v2
name: myapp
description: My application Helm chart
type: application
version: 0.1.0
appVersion: "1.0.0"</code></pre>
                        </div>

                        <p><strong>values.yaml</strong></p>
                        <div class="code-block">
                            <pre><code class="language-yaml">replicaCount: 3

image:
  repository: myapp
  pullPolicy: IfNotPresent
  tag: "latest"

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
  hosts:
    - host: myapp.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: myapp-tls
      hosts:
        - myapp.example.com

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80</code></pre>
                        </div>

                        <h4>Helm команди</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Створення chart
helm create myapp

# Встановлення додатку
helm install myapp ./myapp

# Встановлення з custom values
helm install myapp ./myapp -f production-values.yaml

# Оновлення релізу
helm upgrade myapp ./myapp

# Перегляд релізів
helm list

# Відкат до попередньої версії
helm rollback myapp 1

# Видалення релізу
helm uninstall myapp

# Додавання репозиторіїв
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo update

# Встановлення з репозиторію
helm install my-postgres bitnami/postgresql</code></pre>
                        </div>

                        <h4>Локальне тестування з Minikube</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># Встановлення та запуск Minikube
minikube start --driver=docker --cpus=4 --memory=8g

# Увімкнення addons
minikube addons enable ingress
minikube addons enable metrics-server
minikube addons enable dashboard

# Отримання IP адреси
minikube ip

# Доступ до dashboard
minikube dashboard

# Зупинка та видалення
minikube stop
minikube delete</code></pre>
                        </div>

                        <h4>Managed Kubernetes сервіси</h4>
                        <div class="code-block">
                            <pre><code class="language-bash"># AWS EKS
eksctl create cluster --name my-cluster --region us-west-2

# Google GKE
gcloud container clusters create my-cluster --zone us-central1-a

# Azure AKS
az aks create --resource-group myResourceGroup --name myAKSCluster

# DigitalOcean DOKS
doctl kubernetes cluster create my-cluster --region nyc1</code></pre>
                        </div>

                        <h4>Переваги переходу на Kubernetes</h4>
                        <div class="info-box">
                            <div class="info-box-title">🚀 Коли варто використовувати Kubernetes</div>
                            <ul>
                                <li>Масштабні мікросервісні архітектури</li>
                                <li>Потреба в автоматичному скейлінгу</li>
                                <li>Multi-cloud або hybrid cloud стратегія</li>
                                <li>Складні вимоги до мережевої політики</li>
                                <li>Потреба в GitOps та CI/CD інтеграції</li>
                                <li>Команди з досвідом DevOps практик</li>
                                <li>Великі команди розробки</li>
                            </ul>
                        </div>

                        <h4>Шлях навчання Kubernetes</h4>
                        <div class="info-box">
                            <div class="info-box-title">📚 Рекомендований порядок вивчення</div>
                            <ol>
                                <li>Основи контейнеризації (Docker)</li>
                                <li>Основні концепції Kubernetes</li>
                                <li>Робота з kubectl та маніфестами</li>
                                <li>Networking та Services</li>
                                <li>Persistent Volumes та StatefulSets</li>
                                <li>RBAC та Security</li>
                                <li>Helm та пакетне управління</li>
                                <li>Monitoring та Logging</li>
                                <li>CI/CD з Kubernetes</li>
                                <li>Advanced topics: Operators, Custom Resources</li>
                            </ol>
                        </div>

                        <div class="info-box warning">
                            <div class="info-box-title">⚠️ Важливі моменти</div>
                            <ul>
                                <li>Kubernetes має високу складність - починайте з Docker Swarm для простих проектів</li>
                                <li>Потрібна серйозна інвестиція в навчання команди</li>
                                <li>Значно більше ресурсів потрібно для підтримки</li>
                                <li>Managed сервіси (EKS, GKE, AKS) спрощують управління</li>
                                <li>Починайте з невеликих проектів для набуття досвіду</li>
                            </ul>
                        </div>

                        <p><strong>Висновок:</strong> Docker Swarm відмінно підходить для початку роботи з оркестрацією контейнерів та простих до середніх проектів. Kubernetes стає необхідним при потребі в advanced функціональності, але потребує значних інвестицій у навчання та підтримку.</p>
                    </div>
                </div>
            </article>
        </div>
    </div>

    <footer>
        <div class="container">
            <p>&copy; 2025 ITLearningUA. Навчання IT українською мовою.</p>
        </div>
    </footer>

    <script>
        // Initialize Prism.js
        Prism.highlightAll();
    </script>
    <script src="../../script.js"></script>
</body>
</html>